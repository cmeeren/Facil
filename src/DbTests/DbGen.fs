// Edit or remove this or the below line to regenerate on next build
// Hash: adae1d7fa315860617fc06aec50cb51a5d74cbfad73003710f56d776ddf75ce7

//////////////////////////////////////////
//
// THIS FILE IS AUTOMATICALLY GENERATED
//
// Facil 0.1.2
//
//////////////////////////////////////////

module DbGen

#nowarn "49"

open System
open System.ComponentModel
open System.Data
open System.Threading
open Microsoft.Data.SqlClient
open Microsoft.Data.SqlClient.Server
open Facil.Runtime.GeneratedCodeUtils

module MyPreludeModule =
  let x = 2



module TableDtos =


  module ``dbo`` =


    type ``OptionTableWithDto`` =
      {
        Col1: string option
        Col2: int option
      }


    type ``Table1`` =
      {
        TableCol1: string
        TableCol2: int option
      }


    type ``VoptionTableWithDto`` =
      {
        Col1: string voption
        Col2: int voption
      }


module TableTypes =


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type DoNotUseConstructor = | DoNotUseConstructor
  [<EditorBrowsable(EditorBrowsableState.Never)>]
  let doNotUseConstructorValue = DoNotUseConstructor


  module ``dbo`` =


    type ``AllTypesNonNull`` (__: DoNotUseConstructor) =
      inherit SqlDataRecord ([|
        SqlMetaData("bigint", SqlDbType.BigInt)
        SqlMetaData("binary", SqlDbType.Binary, 42L)
        SqlMetaData("bit", SqlDbType.Bit)
        SqlMetaData("char", SqlDbType.Char, 42L)
        SqlMetaData("date", SqlDbType.Date)
        SqlMetaData("datetime", SqlDbType.DateTime)
        SqlMetaData("datetime2", SqlDbType.DateTime2, 0uy, 3uy)
        SqlMetaData("datetimeoffset", SqlDbType.DateTimeOffset, 0uy, 1uy)
        SqlMetaData("decimal", SqlDbType.Decimal, 10uy, 5uy)
        SqlMetaData("float", SqlDbType.Float)
        SqlMetaData("image", SqlDbType.Image)
        SqlMetaData("int", SqlDbType.Int)
        SqlMetaData("money", SqlDbType.Money)
        SqlMetaData("nchar", SqlDbType.NChar, 42L)
        SqlMetaData("ntext", SqlDbType.NText)
        SqlMetaData("numeric", SqlDbType.Decimal, 8uy, 3uy)
        SqlMetaData("nvarchar", SqlDbType.NVarChar, 42L)
        SqlMetaData("real", SqlDbType.Real)
        SqlMetaData("smalldatetime", SqlDbType.SmallDateTime)
        SqlMetaData("smallint", SqlDbType.SmallInt)
        SqlMetaData("smallmoney", SqlDbType.SmallMoney)
        SqlMetaData("text", SqlDbType.Text)
        SqlMetaData("time", SqlDbType.Time, 0uy, 1uy)
        SqlMetaData("tinyint", SqlDbType.TinyInt)
        SqlMetaData("uniqueidentifier", SqlDbType.UniqueIdentifier)
        SqlMetaData("varbinary", SqlDbType.VarBinary, 42L)
        SqlMetaData("varchar", SqlDbType.VarChar, 42L)
        SqlMetaData("xml", SqlDbType.Xml)
      |])

      static member create
        (
          ``bigint``: int64,
          ``binary``: byte [],
          ``bit``: bool,
          ``char``: string,
          ``date``: DateTime,
          ``datetime``: DateTime,
          ``datetime2``: DateTime,
          ``datetimeoffset``: DateTimeOffset,
          ``decimal``: decimal,
          ``float``: float,
          ``image``: byte [],
          ``int``: int,
          ``money``: decimal,
          ``nchar``: string,
          ``ntext``: string,
          ``numeric``: decimal,
          ``nvarchar``: string,
          ``real``: float32,
          ``smalldatetime``: DateTime,
          ``smallint``: int16,
          ``smallmoney``: decimal,
          ``text``: string,
          ``time``: TimeSpan,
          ``tinyint``: byte,
          ``uniqueidentifier``: Guid,
          ``varbinary``: byte [],
          ``varchar``: string,
          ``xml``: string
        ) =
        let x = ``AllTypesNonNull``(doNotUseConstructorValue)
        x.SetValues(
          ``bigint``,
          ``binary``,
          ``bit``,
          ``char``,
          ``date``,
          ``datetime``,
          ``datetime2``,
          ``datetimeoffset``,
          ``decimal``,
          ``float``,
          ``image``,
          ``int``,
          ``money``,
          ``nchar``,
          ``ntext``,
          ``numeric``,
          ``nvarchar``,
          ``real``,
          ``smalldatetime``,
          ``smallint``,
          ``smallmoney``,
          ``text``,
          ``time``,
          ``tinyint``,
          ``uniqueidentifier``,
          ``varbinary``,
          ``varchar``,
          ``xml``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``AllTypesNonNull``(doNotUseConstructorValue)
        x.SetValues(
          (^a: (member ``bigint``: int64) dto),
          (^a: (member ``binary``: byte []) dto),
          (^a: (member ``bit``: bool) dto),
          (^a: (member ``char``: string) dto),
          (^a: (member ``date``: DateTime) dto),
          (^a: (member ``datetime``: DateTime) dto),
          (^a: (member ``datetime2``: DateTime) dto),
          (^a: (member ``datetimeoffset``: DateTimeOffset) dto),
          (^a: (member ``decimal``: decimal) dto),
          (^a: (member ``float``: float) dto),
          (^a: (member ``image``: byte []) dto),
          (^a: (member ``int``: int) dto),
          (^a: (member ``money``: decimal) dto),
          (^a: (member ``nchar``: string) dto),
          (^a: (member ``ntext``: string) dto),
          (^a: (member ``numeric``: decimal) dto),
          (^a: (member ``nvarchar``: string) dto),
          (^a: (member ``real``: float32) dto),
          (^a: (member ``smalldatetime``: DateTime) dto),
          (^a: (member ``smallint``: int16) dto),
          (^a: (member ``smallmoney``: decimal) dto),
          (^a: (member ``text``: string) dto),
          (^a: (member ``time``: TimeSpan) dto),
          (^a: (member ``tinyint``: byte) dto),
          (^a: (member ``uniqueidentifier``: Guid) dto),
          (^a: (member ``varbinary``: byte []) dto),
          (^a: (member ``varchar``: string) dto),
          (^a: (member ``xml``: string) dto)
        )
        |> ignore
        x


    type ``AllTypesNull`` (__: DoNotUseConstructor) =
      inherit SqlDataRecord ([|
        SqlMetaData("bigint", SqlDbType.BigInt)
        SqlMetaData("binary", SqlDbType.Binary, 42L)
        SqlMetaData("bit", SqlDbType.Bit)
        SqlMetaData("char", SqlDbType.Char, 42L)
        SqlMetaData("date", SqlDbType.Date)
        SqlMetaData("datetime", SqlDbType.DateTime)
        SqlMetaData("datetime2", SqlDbType.DateTime2, 0uy, 3uy)
        SqlMetaData("datetimeoffset", SqlDbType.DateTimeOffset, 0uy, 1uy)
        SqlMetaData("decimal", SqlDbType.Decimal, 10uy, 5uy)
        SqlMetaData("float", SqlDbType.Float)
        SqlMetaData("image", SqlDbType.Image)
        SqlMetaData("int", SqlDbType.Int)
        SqlMetaData("money", SqlDbType.Money)
        SqlMetaData("nchar", SqlDbType.NChar, 42L)
        SqlMetaData("ntext", SqlDbType.NText)
        SqlMetaData("numeric", SqlDbType.Decimal, 8uy, 3uy)
        SqlMetaData("nvarchar", SqlDbType.NVarChar, 42L)
        SqlMetaData("real", SqlDbType.Real)
        SqlMetaData("smalldatetime", SqlDbType.SmallDateTime)
        SqlMetaData("smallint", SqlDbType.SmallInt)
        SqlMetaData("smallmoney", SqlDbType.SmallMoney)
        SqlMetaData("text", SqlDbType.Text)
        SqlMetaData("time", SqlDbType.Time, 0uy, 1uy)
        SqlMetaData("tinyint", SqlDbType.TinyInt)
        SqlMetaData("uniqueidentifier", SqlDbType.UniqueIdentifier)
        SqlMetaData("varbinary", SqlDbType.VarBinary, 42L)
        SqlMetaData("varchar", SqlDbType.VarChar, 42L)
        SqlMetaData("xml", SqlDbType.Xml)
      |])

      static member create
        (
          ``bigint``: int64 option,
          ``binary``: byte [] option,
          ``bit``: bool option,
          ``char``: string option,
          ``date``: DateTime option,
          ``datetime``: DateTime option,
          ``datetime2``: DateTime option,
          ``datetimeoffset``: DateTimeOffset option,
          ``decimal``: decimal option,
          ``float``: float option,
          ``image``: byte [] option,
          ``int``: int option,
          ``money``: decimal option,
          ``nchar``: string option,
          ``ntext``: string option,
          ``numeric``: decimal option,
          ``nvarchar``: string option,
          ``real``: float32 option,
          ``smalldatetime``: DateTime option,
          ``smallint``: int16 option,
          ``smallmoney``: decimal option,
          ``text``: string option,
          ``time``: TimeSpan option,
          ``tinyint``: byte option,
          ``uniqueidentifier``: Guid option,
          ``varbinary``: byte [] option,
          ``varchar``: string option,
          ``xml``: string option
        ) =
        let x = ``AllTypesNull``(doNotUseConstructorValue)
        x.SetValues(
          Option.toDbNull ``bigint``,
          Option.toDbNull ``binary``,
          Option.toDbNull ``bit``,
          Option.toDbNull ``char``,
          Option.toDbNull ``date``,
          Option.toDbNull ``datetime``,
          Option.toDbNull ``datetime2``,
          Option.toDbNull ``datetimeoffset``,
          Option.toDbNull ``decimal``,
          Option.toDbNull ``float``,
          Option.toDbNull ``image``,
          Option.toDbNull ``int``,
          Option.toDbNull ``money``,
          Option.toDbNull ``nchar``,
          Option.toDbNull ``ntext``,
          Option.toDbNull ``numeric``,
          Option.toDbNull ``nvarchar``,
          Option.toDbNull ``real``,
          Option.toDbNull ``smalldatetime``,
          Option.toDbNull ``smallint``,
          Option.toDbNull ``smallmoney``,
          Option.toDbNull ``text``,
          Option.toDbNull ``time``,
          Option.toDbNull ``tinyint``,
          Option.toDbNull ``uniqueidentifier``,
          Option.toDbNull ``varbinary``,
          Option.toDbNull ``varchar``,
          Option.toDbNull ``xml``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``AllTypesNull``(doNotUseConstructorValue)
        x.SetValues(
          Option.toDbNull (^a: (member ``bigint``: int64 option) dto),
          Option.toDbNull (^a: (member ``binary``: byte [] option) dto),
          Option.toDbNull (^a: (member ``bit``: bool option) dto),
          Option.toDbNull (^a: (member ``char``: string option) dto),
          Option.toDbNull (^a: (member ``date``: DateTime option) dto),
          Option.toDbNull (^a: (member ``datetime``: DateTime option) dto),
          Option.toDbNull (^a: (member ``datetime2``: DateTime option) dto),
          Option.toDbNull (^a: (member ``datetimeoffset``: DateTimeOffset option) dto),
          Option.toDbNull (^a: (member ``decimal``: decimal option) dto),
          Option.toDbNull (^a: (member ``float``: float option) dto),
          Option.toDbNull (^a: (member ``image``: byte [] option) dto),
          Option.toDbNull (^a: (member ``int``: int option) dto),
          Option.toDbNull (^a: (member ``money``: decimal option) dto),
          Option.toDbNull (^a: (member ``nchar``: string option) dto),
          Option.toDbNull (^a: (member ``ntext``: string option) dto),
          Option.toDbNull (^a: (member ``numeric``: decimal option) dto),
          Option.toDbNull (^a: (member ``nvarchar``: string option) dto),
          Option.toDbNull (^a: (member ``real``: float32 option) dto),
          Option.toDbNull (^a: (member ``smalldatetime``: DateTime option) dto),
          Option.toDbNull (^a: (member ``smallint``: int16 option) dto),
          Option.toDbNull (^a: (member ``smallmoney``: decimal option) dto),
          Option.toDbNull (^a: (member ``text``: string option) dto),
          Option.toDbNull (^a: (member ``time``: TimeSpan option) dto),
          Option.toDbNull (^a: (member ``tinyint``: byte option) dto),
          Option.toDbNull (^a: (member ``uniqueidentifier``: Guid option) dto),
          Option.toDbNull (^a: (member ``varbinary``: byte [] option) dto),
          Option.toDbNull (^a: (member ``varchar``: string option) dto),
          Option.toDbNull (^a: (member ``xml``: string option) dto)
        )
        |> ignore
        x


    type ``MultiColNonNull`` (__: DoNotUseConstructor) =
      inherit SqlDataRecord ([|
        SqlMetaData("Foo", SqlDbType.Int)
        SqlMetaData("Bar", SqlDbType.NVarChar, 50L)
      |])

      static member create
        (
          ``Foo``: int,
          ``Bar``: string
        ) =
        let x = ``MultiColNonNull``(doNotUseConstructorValue)
        x.SetValues(
          ``Foo``,
          ``Bar``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``MultiColNonNull``(doNotUseConstructorValue)
        x.SetValues(
          (^a: (member ``Foo``: int) dto),
          (^a: (member ``Bar``: string) dto)
        )
        |> ignore
        x


    type ``MultiColNull`` (__: DoNotUseConstructor) =
      inherit SqlDataRecord ([|
        SqlMetaData("Foo", SqlDbType.Int)
        SqlMetaData("Bar", SqlDbType.NVarChar, 50L)
      |])

      static member create
        (
          ``Foo``: int option,
          ``Bar``: string option
        ) =
        let x = ``MultiColNull``(doNotUseConstructorValue)
        x.SetValues(
          Option.toDbNull ``Foo``,
          Option.toDbNull ``Bar``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``MultiColNull``(doNotUseConstructorValue)
        x.SetValues(
          Option.toDbNull (^a: (member ``Foo``: int option) dto),
          Option.toDbNull (^a: (member ``Bar``: string option) dto)
        )
        |> ignore
        x


    type ``MultiColNullVoption`` (__: DoNotUseConstructor) =
      inherit SqlDataRecord ([|
        SqlMetaData("Foo", SqlDbType.Int)
        SqlMetaData("Bar", SqlDbType.NVarChar, 50L)
      |])

      static member create
        (
          ``Foo``: int voption,
          ``Bar``: string voption
        ) =
        let x = ``MultiColNullVoption``(doNotUseConstructorValue)
        x.SetValues(
          ValueOption.toDbNull ``Foo``,
          ValueOption.toDbNull ``Bar``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``MultiColNullVoption``(doNotUseConstructorValue)
        x.SetValues(
          ValueOption.toDbNull (^a: (member ``Foo``: int voption) dto),
          ValueOption.toDbNull (^a: (member ``Bar``: string voption) dto)
        )
        |> ignore
        x


    type ``SingleColNonNull`` (__: DoNotUseConstructor) =
      inherit SqlDataRecord ([|
        SqlMetaData("Foo", SqlDbType.Int)
      |])

      static member create
        (
          ``Foo``: int
        ) =
        let x = ``SingleColNonNull``(doNotUseConstructorValue)
        x.SetValues(
          ``Foo``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``SingleColNonNull``(doNotUseConstructorValue)
        x.SetValues(
          (^a: (member ``Foo``: int) dto)
        )
        |> ignore
        x


    type ``SingleColNull`` (__: DoNotUseConstructor) =
      inherit SqlDataRecord ([|
        SqlMetaData("Foo", SqlDbType.Int)
      |])

      static member create
        (
          ``Foo``: int option
        ) =
        let x = ``SingleColNull``(doNotUseConstructorValue)
        x.SetValues(
          Option.toDbNull ``Foo``
        )
        |> ignore
        x

      static member inline create (dto: ^a) =
        let x = ``SingleColNull``(doNotUseConstructorValue)
        x.SetValues(
          Option.toDbNull (^a: (member ``Foo``: int option) dto)
        )
        |> ignore
        x


module Procedures =


  module ``dbo`` =


    type ``ProcInsert`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcInsert"
        userConfigureCmd cmd

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcInsert``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcInsert``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeNonQuery connStr conn this.configureConn (configureCmd this.userConfigureCmd)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcOptionIn_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionIn"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcOptionIn`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionIn``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcOptionIn``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``param1``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
          |]
        ``ProcOptionIn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
          |]
        ``ProcOptionIn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcOptionOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionOut"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcOptionOut`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionOut``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcOptionOut``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``param1``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
          |]
        ``ProcOptionOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
          |]
        ``ProcOptionOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    type ``ProcOptionTableOutWithDto`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionTableOutWithDto"
        userConfigureCmd cmd

      let mutable ``ordinal_Col1`` = 0
      let mutable ``ordinal_Col2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

      let getItem (reader: SqlDataReader) : TableDtos.dbo.OptionTableWithDto =
        {
          ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then None else reader.GetString ``ordinal_Col1`` |> Some
          ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionTableOutWithDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcOptionTableOutWithDto``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    type ``ProcOptionTableOutWithoutDto`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionTableOutWithoutDto"
        userConfigureCmd cmd

      let mutable ``ordinal_Col1`` = 0
      let mutable ``ordinal_Col2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

      let getItem (reader: SqlDataReader) =
        {|
          ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then None else reader.GetString ``ordinal_Col1`` |> Some
          ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionTableOutWithoutDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcOptionTableOutWithoutDto``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcOptionTvpInOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcOptionTvpInOut"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcOptionTvpInOut`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcOptionTvpInOut``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcOptionTvpInOut``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``tvp``: seq<TableTypes.``dbo``.``MultiColNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = ``tvp``)
          |]
        ``ProcOptionTvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
          |]
        ``ProcOptionTvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    type ``ProcSelectFromTable`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcSelectFromTable"
        userConfigureCmd cmd

      let mutable ``ordinal_TableCol1`` = 0
      let mutable ``ordinal_TableCol2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
        ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

      let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
        {
          ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
          ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcSelectFromTable``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcSelectFromTable``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    type ``ProcSelectFromTableExtended`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcSelectFromTableExtended"
        userConfigureCmd cmd

      let mutable ``ordinal_TableCol1`` = 0
      let mutable ``ordinal_TableCol2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
        ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

      let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
        {
          ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
          ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcSelectFromTableExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcSelectFromTableExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    type ``ProcToBeModified`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcToBeModified"
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetString ``ordinal_Bar``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcToBeModified``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcToBeModified``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcVoptionIn_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionIn"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcVoptionIn`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionIn``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcVoptionIn``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``param1``: string voption
        ) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = ValueOption.toDbNull ``param1``)
          |]
        ``ProcVoptionIn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = ValueOption.toDbNull (^a: (member ``Param1``: string voption) dto))
          |]
        ``ProcVoptionIn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcVoptionOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionOut"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then ValueNone else reader.GetString 0 |> ValueSome

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsyncVoption connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingleVoption connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcVoptionOut`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionOut``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcVoptionOut``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``param1``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
          |]
        ``ProcVoptionOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
          |]
        ``ProcVoptionOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    type ``ProcVoptionTableOutWithDto`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionTableOutWithDto"
        userConfigureCmd cmd

      let mutable ``ordinal_Col1`` = 0
      let mutable ``ordinal_Col2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

      let getItem (reader: SqlDataReader) : TableDtos.dbo.VoptionTableWithDto =
        {
          ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then ValueNone else reader.GetString ``ordinal_Col1`` |> ValueSome
          ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then ValueNone else reader.GetInt32 ``ordinal_Col2`` |> ValueSome
        }

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionTableOutWithDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcVoptionTableOutWithDto``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsyncVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingleVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    type ``ProcVoptionTableOutWithoutDto`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionTableOutWithoutDto"
        userConfigureCmd cmd

      let mutable ``ordinal_Col1`` = 0
      let mutable ``ordinal_Col2`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

      let getItem (reader: SqlDataReader) =
        {|
          ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then ValueNone else reader.GetString ``ordinal_Col1`` |> ValueSome
          ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then ValueNone else reader.GetInt32 ``ordinal_Col2`` |> ValueSome
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionTableOutWithoutDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcVoptionTableOutWithoutDto``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsyncVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingleVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcVoptionTvpInOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcVoptionTvpInOut"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then ValueNone else reader.GetInt32 ``ordinal_Foo`` |> ValueSome
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then ValueNone else reader.GetString ``ordinal_Bar`` |> ValueSome
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsyncVoption connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingleVoption connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcVoptionTvpInOut`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcVoptionTvpInOut``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcVoptionTvpInOut``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``tvp``: seq<TableTypes.``dbo``.``MultiColNullVoption``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNullVoption", Value = ``tvp``)
          |]
        ``ProcVoptionTvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNullVoption", Value = (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNullVoption``>) dto))
          |]
        ``ProcVoptionTvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypes_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypes"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_rowversion`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_timestamp`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_rowversion`` <- reader.GetOrdinal "rowversion"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_timestamp`` <- reader.GetOrdinal "timestamp"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
          ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
          ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
          ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
          ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
          ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
          ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
          ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
          ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
          ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
          ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
          ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
          ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
          ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
          ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
          ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
          ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
          ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
          ``rowversion`` = if reader.IsDBNull ``ordinal_rowversion`` then None else reader.GetBytes ``ordinal_rowversion`` |> Some
          ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
          ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
          ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
          ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
          ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
          ``timestamp`` = if reader.IsDBNull ``ordinal_timestamp`` then None else reader.GetBytes ``ordinal_timestamp`` |> Some
          ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
          ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
          ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
          ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
          ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithAllTypes`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypes``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypes``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``bigint``: int64,
          ``binary``: byte [],
          ``bit``: bool,
          ``char``: string,
          ``date``: DateTime,
          ``datetime``: DateTime,
          ``datetime2``: DateTime,
          ``datetimeoffset``: DateTimeOffset,
          ``decimal``: decimal,
          ``float``: float,
          ``image``: byte [],
          ``int``: int,
          ``money``: decimal,
          ``nchar``: string,
          ``ntext``: string,
          ``numeric``: decimal,
          ``nvarchar``: string,
          ``real``: float32,
          ``rowversion``: byte [],
          ``smalldatetime``: DateTime,
          ``smallint``: int16,
          ``smallmoney``: decimal,
          ``text``: string,
          ``time``: TimeSpan,
          ``timestamp``: byte [],
          ``tinyint``: byte,
          ``uniqueidentifier``: Guid,
          ``varbinary``: byte [],
          ``varchar``: string,
          ``xml``: string
        ) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = ``bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = ``binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = ``bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = ``char``)
            SqlParameter("@date", SqlDbType.Date, Value = ``date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = ``datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = ``datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = ``datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = ``decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = ``float``)
            SqlParameter("@image", SqlDbType.Image, Value = ``image``)
            SqlParameter("@int", SqlDbType.Int, Value = ``int``)
            SqlParameter("@money", SqlDbType.Money, Value = ``money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = ``nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = ``ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = ``numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = ``nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = ``real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = ``rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = ``smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = ``smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = ``smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = ``text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = ``time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = ``timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = ``tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = ``uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = ``varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = ``xml``)
          |]
        ``ProcWithAllTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = (^a: (member ``Bigint``: int64) dto))
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = (^a: (member ``Binary``: byte []) dto))
            SqlParameter("@bit", SqlDbType.Bit, Value = (^a: (member ``Bit``: bool) dto))
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = (^a: (member ``Char``: string) dto))
            SqlParameter("@date", SqlDbType.Date, Value = (^a: (member ``Date``: DateTime) dto))
            SqlParameter("@datetime", SqlDbType.DateTime, Value = (^a: (member ``Datetime``: DateTime) dto))
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = (^a: (member ``Datetime2``: DateTime) dto))
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = (^a: (member ``Datetimeoffset``: DateTimeOffset) dto))
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = (^a: (member ``Decimal``: decimal) dto))
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = (^a: (member ``Float``: float) dto))
            SqlParameter("@image", SqlDbType.Image, Value = (^a: (member ``Image``: byte []) dto))
            SqlParameter("@int", SqlDbType.Int, Value = (^a: (member ``Int``: int) dto))
            SqlParameter("@money", SqlDbType.Money, Value = (^a: (member ``Money``: decimal) dto))
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = (^a: (member ``Nchar``: string) dto))
            SqlParameter("@ntext", SqlDbType.NText, Value = (^a: (member ``Ntext``: string) dto))
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = (^a: (member ``Numeric``: decimal) dto))
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Nvarchar``: string) dto))
            SqlParameter("@real", SqlDbType.Real, Value = (^a: (member ``Real``: float32) dto))
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = (^a: (member ``Rowversion``: byte []) dto))
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = (^a: (member ``Smalldatetime``: DateTime) dto))
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = (^a: (member ``Smallint``: int16) dto))
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = (^a: (member ``Smallmoney``: decimal) dto))
            SqlParameter("@text", SqlDbType.Text, Value = (^a: (member ``Text``: string) dto))
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = (^a: (member ``Time``: TimeSpan) dto))
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = (^a: (member ``Timestamp``: byte []) dto))
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = (^a: (member ``Tinyint``: byte) dto))
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Uniqueidentifier``: Guid) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = (^a: (member ``Varbinary``: byte []) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = (^a: (member ``Varchar``: string) dto))
            SqlParameter("@xml", SqlDbType.Xml, Value = (^a: (member ``Xml``: string) dto))
          |]
        ``ProcWithAllTypes_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_rowversion`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_timestamp`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_rowversion`` <- reader.GetOrdinal "rowversion"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_timestamp`` <- reader.GetOrdinal "timestamp"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
          ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
          ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
          ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
          ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
          ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
          ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
          ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
          ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
          ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
          ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
          ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
          ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
          ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
          ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
          ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
          ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
          ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
          ``rowversion`` = if reader.IsDBNull ``ordinal_rowversion`` then None else reader.GetBytes ``ordinal_rowversion`` |> Some
          ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
          ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
          ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
          ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
          ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
          ``timestamp`` = if reader.IsDBNull ``ordinal_timestamp`` then None else reader.GetBytes ``ordinal_timestamp`` |> Some
          ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
          ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
          ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
          ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
          ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithAllTypesExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypesExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``bigint``: int64,
          ``binary``: byte [],
          ``bit``: bool,
          ``char``: string,
          ``date``: DateTime,
          ``datetime``: DateTime,
          ``datetime2``: DateTime,
          ``datetimeoffset``: DateTimeOffset,
          ``decimal``: decimal,
          ``float``: float,
          ``image``: byte [],
          ``int``: int,
          ``money``: decimal,
          ``nchar``: string,
          ``ntext``: string,
          ``numeric``: decimal,
          ``nvarchar``: string,
          ``real``: float32,
          ``rowversion``: byte [],
          ``smalldatetime``: DateTime,
          ``smallint``: int16,
          ``smallmoney``: decimal,
          ``text``: string,
          ``time``: TimeSpan,
          ``timestamp``: byte [],
          ``tinyint``: byte,
          ``uniqueidentifier``: Guid,
          ``varbinary``: byte [],
          ``varchar``: string,
          ``xml``: string
        ) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = ``bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = ``binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = ``bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = ``char``)
            SqlParameter("@date", SqlDbType.Date, Value = ``date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = ``datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = ``datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = ``datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = ``decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = ``float``)
            SqlParameter("@image", SqlDbType.Image, Value = ``image``)
            SqlParameter("@int", SqlDbType.Int, Value = ``int``)
            SqlParameter("@money", SqlDbType.Money, Value = ``money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = ``nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = ``ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = ``numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = ``nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = ``real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = ``rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = ``smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = ``smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = ``smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = ``text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = ``time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = ``timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = ``tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = ``uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = ``varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = ``xml``)
          |]
        ``ProcWithAllTypesExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = (^a: (member ``Bigint``: int64) dto))
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = (^a: (member ``Binary``: byte []) dto))
            SqlParameter("@bit", SqlDbType.Bit, Value = (^a: (member ``Bit``: bool) dto))
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = (^a: (member ``Char``: string) dto))
            SqlParameter("@date", SqlDbType.Date, Value = (^a: (member ``Date``: DateTime) dto))
            SqlParameter("@datetime", SqlDbType.DateTime, Value = (^a: (member ``Datetime``: DateTime) dto))
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = (^a: (member ``Datetime2``: DateTime) dto))
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = (^a: (member ``Datetimeoffset``: DateTimeOffset) dto))
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = (^a: (member ``Decimal``: decimal) dto))
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = (^a: (member ``Float``: float) dto))
            SqlParameter("@image", SqlDbType.Image, Value = (^a: (member ``Image``: byte []) dto))
            SqlParameter("@int", SqlDbType.Int, Value = (^a: (member ``Int``: int) dto))
            SqlParameter("@money", SqlDbType.Money, Value = (^a: (member ``Money``: decimal) dto))
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = (^a: (member ``Nchar``: string) dto))
            SqlParameter("@ntext", SqlDbType.NText, Value = (^a: (member ``Ntext``: string) dto))
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = (^a: (member ``Numeric``: decimal) dto))
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Nvarchar``: string) dto))
            SqlParameter("@real", SqlDbType.Real, Value = (^a: (member ``Real``: float32) dto))
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = (^a: (member ``Rowversion``: byte []) dto))
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = (^a: (member ``Smalldatetime``: DateTime) dto))
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = (^a: (member ``Smallint``: int16) dto))
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = (^a: (member ``Smallmoney``: decimal) dto))
            SqlParameter("@text", SqlDbType.Text, Value = (^a: (member ``Text``: string) dto))
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = (^a: (member ``Time``: TimeSpan) dto))
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = (^a: (member ``Timestamp``: byte []) dto))
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = (^a: (member ``Tinyint``: byte) dto))
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Uniqueidentifier``: Guid) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = (^a: (member ``Varbinary``: byte []) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = (^a: (member ``Varchar``: string) dto))
            SqlParameter("@xml", SqlDbType.Xml, Value = (^a: (member ``Xml``: string) dto))
          |]
        ``ProcWithAllTypesExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesFromTvpNonNull_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesFromTvpNonNull"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = reader.GetInt64 ``ordinal_bigint``
          ``binary`` = reader.GetBytes ``ordinal_binary``
          ``bit`` = reader.GetBoolean ``ordinal_bit``
          ``char`` = reader.GetString ``ordinal_char``
          ``date`` = reader.GetDateTime ``ordinal_date``
          ``datetime`` = reader.GetDateTime ``ordinal_datetime``
          ``datetime2`` = reader.GetDateTime ``ordinal_datetime2``
          ``datetimeoffset`` = reader.GetDateTimeOffset ``ordinal_datetimeoffset``
          ``decimal`` = reader.GetDecimal ``ordinal_decimal``
          ``float`` = reader.GetDouble ``ordinal_float``
          ``image`` = reader.GetBytes ``ordinal_image``
          ``int`` = reader.GetInt32 ``ordinal_int``
          ``money`` = reader.GetDecimal ``ordinal_money``
          ``nchar`` = reader.GetString ``ordinal_nchar``
          ``ntext`` = reader.GetString ``ordinal_ntext``
          ``numeric`` = reader.GetDecimal ``ordinal_numeric``
          ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
          ``real`` = reader.GetFloat ``ordinal_real``
          ``smalldatetime`` = reader.GetDateTime ``ordinal_smalldatetime``
          ``smallint`` = reader.GetInt16 ``ordinal_smallint``
          ``smallmoney`` = reader.GetDecimal ``ordinal_smallmoney``
          ``text`` = reader.GetString ``ordinal_text``
          ``time`` = reader.GetTimeSpan ``ordinal_time``
          ``tinyint`` = reader.GetByte ``ordinal_tinyint``
          ``uniqueidentifier`` = reader.GetGuid ``ordinal_uniqueidentifier``
          ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
          ``varchar`` = reader.GetString ``ordinal_varchar``
          ``xml`` = reader.GetString ``ordinal_xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithAllTypesFromTvpNonNull`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesFromTvpNonNull``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypesFromTvpNonNull``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``params``: seq<TableTypes.``dbo``.``AllTypesNonNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNonNull", Value = ``params``)
          |]
        ``ProcWithAllTypesFromTvpNonNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNonNull", Value = (^a: (member ``Params``: #seq<TableTypes.``dbo``.``AllTypesNonNull``>) dto))
          |]
        ``ProcWithAllTypesFromTvpNonNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesFromTvpNonNullExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesFromTvpNonNullExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = reader.GetInt64 ``ordinal_bigint``
          ``binary`` = reader.GetBytes ``ordinal_binary``
          ``bit`` = reader.GetBoolean ``ordinal_bit``
          ``char`` = reader.GetString ``ordinal_char``
          ``date`` = reader.GetDateTime ``ordinal_date``
          ``datetime`` = reader.GetDateTime ``ordinal_datetime``
          ``datetime2`` = reader.GetDateTime ``ordinal_datetime2``
          ``datetimeoffset`` = reader.GetDateTimeOffset ``ordinal_datetimeoffset``
          ``decimal`` = reader.GetDecimal ``ordinal_decimal``
          ``float`` = reader.GetDouble ``ordinal_float``
          ``image`` = reader.GetBytes ``ordinal_image``
          ``int`` = reader.GetInt32 ``ordinal_int``
          ``money`` = reader.GetDecimal ``ordinal_money``
          ``nchar`` = reader.GetString ``ordinal_nchar``
          ``ntext`` = reader.GetString ``ordinal_ntext``
          ``numeric`` = reader.GetDecimal ``ordinal_numeric``
          ``nvarchar`` = reader.GetString ``ordinal_nvarchar``
          ``real`` = reader.GetFloat ``ordinal_real``
          ``smalldatetime`` = reader.GetDateTime ``ordinal_smalldatetime``
          ``smallint`` = reader.GetInt16 ``ordinal_smallint``
          ``smallmoney`` = reader.GetDecimal ``ordinal_smallmoney``
          ``text`` = reader.GetString ``ordinal_text``
          ``time`` = reader.GetTimeSpan ``ordinal_time``
          ``tinyint`` = reader.GetByte ``ordinal_tinyint``
          ``uniqueidentifier`` = reader.GetGuid ``ordinal_uniqueidentifier``
          ``varbinary`` = reader.GetBytes ``ordinal_varbinary``
          ``varchar`` = reader.GetString ``ordinal_varchar``
          ``xml`` = reader.GetString ``ordinal_xml``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithAllTypesFromTvpNonNullExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesFromTvpNonNullExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypesFromTvpNonNullExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``params``: seq<TableTypes.``dbo``.``AllTypesNonNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNonNull", Value = ``params``)
          |]
        ``ProcWithAllTypesFromTvpNonNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNonNull", Value = (^a: (member ``Params``: #seq<TableTypes.``dbo``.``AllTypesNonNull``>) dto))
          |]
        ``ProcWithAllTypesFromTvpNonNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesFromTvpNull_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesFromTvpNull"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
          ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
          ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
          ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
          ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
          ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
          ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
          ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
          ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
          ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
          ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
          ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
          ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
          ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
          ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
          ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
          ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
          ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
          ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
          ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
          ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
          ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
          ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
          ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
          ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
          ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
          ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
          ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithAllTypesFromTvpNull`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesFromTvpNull``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypesFromTvpNull``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``params``: seq<TableTypes.``dbo``.``AllTypesNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNull", Value = ``params``)
          |]
        ``ProcWithAllTypesFromTvpNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNull", Value = (^a: (member ``Params``: #seq<TableTypes.``dbo``.``AllTypesNull``>) dto))
          |]
        ``ProcWithAllTypesFromTvpNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesFromTvpNullExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesFromTvpNullExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
          ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
          ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
          ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
          ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
          ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
          ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
          ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
          ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
          ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
          ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
          ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
          ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
          ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
          ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
          ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
          ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
          ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
          ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
          ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
          ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
          ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
          ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
          ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
          ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
          ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
          ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
          ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithAllTypesFromTvpNullExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesFromTvpNullExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypesFromTvpNullExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``params``: seq<TableTypes.``dbo``.``AllTypesNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNull", Value = ``params``)
          |]
        ``ProcWithAllTypesFromTvpNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@params", SqlDbType.Structured, TypeName = "dbo.AllTypesNull", Value = (^a: (member ``Params``: #seq<TableTypes.``dbo``.``AllTypesNull``>) dto))
          |]
        ``ProcWithAllTypesFromTvpNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesNull_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesNull"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_rowversion`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_timestamp`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_rowversion`` <- reader.GetOrdinal "rowversion"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_timestamp`` <- reader.GetOrdinal "timestamp"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
          ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
          ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
          ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
          ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
          ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
          ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
          ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
          ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
          ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
          ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
          ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
          ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
          ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
          ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
          ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
          ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
          ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
          ``rowversion`` = if reader.IsDBNull ``ordinal_rowversion`` then None else reader.GetBytes ``ordinal_rowversion`` |> Some
          ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
          ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
          ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
          ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
          ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
          ``timestamp`` = if reader.IsDBNull ``ordinal_timestamp`` then None else reader.GetBytes ``ordinal_timestamp`` |> Some
          ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
          ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
          ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
          ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
          ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithAllTypesNull`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesNull``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypesNull``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``bigint``: int64 option,
          ``binary``: byte [] option,
          ``bit``: bool option,
          ``char``: string option,
          ``date``: DateTime option,
          ``datetime``: DateTime option,
          ``datetime2``: DateTime option,
          ``datetimeoffset``: DateTimeOffset option,
          ``decimal``: decimal option,
          ``float``: float option,
          ``image``: byte [] option,
          ``int``: int option,
          ``money``: decimal option,
          ``nchar``: string option,
          ``ntext``: string option,
          ``numeric``: decimal option,
          ``nvarchar``: string option,
          ``real``: float32 option,
          ``rowversion``: byte [] option,
          ``smalldatetime``: DateTime option,
          ``smallint``: int16 option,
          ``smallmoney``: decimal option,
          ``text``: string option,
          ``time``: TimeSpan option,
          ``timestamp``: byte [] option,
          ``tinyint``: byte option,
          ``uniqueidentifier``: Guid option,
          ``varbinary``: byte [] option,
          ``varchar``: string option,
          ``xml``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = Option.toDbNull ``bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull ``binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = Option.toDbNull ``bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = Option.toDbNull ``char``)
            SqlParameter("@date", SqlDbType.Date, Value = Option.toDbNull ``date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = Option.toDbNull ``datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull ``datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull ``datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull ``decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = Option.toDbNull ``float``)
            SqlParameter("@image", SqlDbType.Image, Value = Option.toDbNull ``image``)
            SqlParameter("@int", SqlDbType.Int, Value = Option.toDbNull ``int``)
            SqlParameter("@money", SqlDbType.Money, Value = Option.toDbNull ``money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull ``nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = Option.toDbNull ``ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull ``numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull ``nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = Option.toDbNull ``real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = Option.toDbNull ``rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull ``smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = Option.toDbNull ``smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull ``smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = Option.toDbNull ``text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = Option.toDbNull ``time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = Option.toDbNull ``timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = Option.toDbNull ``tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull ``uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull ``varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = Option.toDbNull ``xml``)
          |]
        ``ProcWithAllTypesNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = Option.toDbNull (^a: (member ``Bigint``: int64 option) dto))
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull (^a: (member ``Binary``: byte [] option) dto))
            SqlParameter("@bit", SqlDbType.Bit, Value = Option.toDbNull (^a: (member ``Bit``: bool option) dto))
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = Option.toDbNull (^a: (member ``Char``: string option) dto))
            SqlParameter("@date", SqlDbType.Date, Value = Option.toDbNull (^a: (member ``Date``: DateTime option) dto))
            SqlParameter("@datetime", SqlDbType.DateTime, Value = Option.toDbNull (^a: (member ``Datetime``: DateTime option) dto))
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull (^a: (member ``Datetime2``: DateTime option) dto))
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull (^a: (member ``Datetimeoffset``: DateTimeOffset option) dto))
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull (^a: (member ``Decimal``: decimal option) dto))
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = Option.toDbNull (^a: (member ``Float``: float option) dto))
            SqlParameter("@image", SqlDbType.Image, Value = Option.toDbNull (^a: (member ``Image``: byte [] option) dto))
            SqlParameter("@int", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Int``: int option) dto))
            SqlParameter("@money", SqlDbType.Money, Value = Option.toDbNull (^a: (member ``Money``: decimal option) dto))
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nchar``: string option) dto))
            SqlParameter("@ntext", SqlDbType.NText, Value = Option.toDbNull (^a: (member ``Ntext``: string option) dto))
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull (^a: (member ``Numeric``: decimal option) dto))
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nvarchar``: string option) dto))
            SqlParameter("@real", SqlDbType.Real, Value = Option.toDbNull (^a: (member ``Real``: float32 option) dto))
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = Option.toDbNull (^a: (member ``Rowversion``: byte [] option) dto))
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull (^a: (member ``Smalldatetime``: DateTime option) dto))
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = Option.toDbNull (^a: (member ``Smallint``: int16 option) dto))
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull (^a: (member ``Smallmoney``: decimal option) dto))
            SqlParameter("@text", SqlDbType.Text, Value = Option.toDbNull (^a: (member ``Text``: string option) dto))
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = Option.toDbNull (^a: (member ``Time``: TimeSpan option) dto))
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = Option.toDbNull (^a: (member ``Timestamp``: byte [] option) dto))
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = Option.toDbNull (^a: (member ``Tinyint``: byte option) dto))
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull (^a: (member ``Uniqueidentifier``: Guid option) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull (^a: (member ``Varbinary``: byte [] option) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Varchar``: string option) dto))
            SqlParameter("@xml", SqlDbType.Xml, Value = Option.toDbNull (^a: (member ``Xml``: string option) dto))
          |]
        ``ProcWithAllTypesNull_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithAllTypesNullExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithAllTypesNullExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_bigint`` = 0
      let mutable ``ordinal_binary`` = 0
      let mutable ``ordinal_bit`` = 0
      let mutable ``ordinal_char`` = 0
      let mutable ``ordinal_date`` = 0
      let mutable ``ordinal_datetime`` = 0
      let mutable ``ordinal_datetime2`` = 0
      let mutable ``ordinal_datetimeoffset`` = 0
      let mutable ``ordinal_decimal`` = 0
      let mutable ``ordinal_float`` = 0
      let mutable ``ordinal_image`` = 0
      let mutable ``ordinal_int`` = 0
      let mutable ``ordinal_money`` = 0
      let mutable ``ordinal_nchar`` = 0
      let mutable ``ordinal_ntext`` = 0
      let mutable ``ordinal_numeric`` = 0
      let mutable ``ordinal_nvarchar`` = 0
      let mutable ``ordinal_real`` = 0
      let mutable ``ordinal_rowversion`` = 0
      let mutable ``ordinal_smalldatetime`` = 0
      let mutable ``ordinal_smallint`` = 0
      let mutable ``ordinal_smallmoney`` = 0
      let mutable ``ordinal_text`` = 0
      let mutable ``ordinal_time`` = 0
      let mutable ``ordinal_timestamp`` = 0
      let mutable ``ordinal_tinyint`` = 0
      let mutable ``ordinal_uniqueidentifier`` = 0
      let mutable ``ordinal_varbinary`` = 0
      let mutable ``ordinal_varchar`` = 0
      let mutable ``ordinal_xml`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_bigint`` <- reader.GetOrdinal "bigint"
        ``ordinal_binary`` <- reader.GetOrdinal "binary"
        ``ordinal_bit`` <- reader.GetOrdinal "bit"
        ``ordinal_char`` <- reader.GetOrdinal "char"
        ``ordinal_date`` <- reader.GetOrdinal "date"
        ``ordinal_datetime`` <- reader.GetOrdinal "datetime"
        ``ordinal_datetime2`` <- reader.GetOrdinal "datetime2"
        ``ordinal_datetimeoffset`` <- reader.GetOrdinal "datetimeoffset"
        ``ordinal_decimal`` <- reader.GetOrdinal "decimal"
        ``ordinal_float`` <- reader.GetOrdinal "float"
        ``ordinal_image`` <- reader.GetOrdinal "image"
        ``ordinal_int`` <- reader.GetOrdinal "int"
        ``ordinal_money`` <- reader.GetOrdinal "money"
        ``ordinal_nchar`` <- reader.GetOrdinal "nchar"
        ``ordinal_ntext`` <- reader.GetOrdinal "ntext"
        ``ordinal_numeric`` <- reader.GetOrdinal "numeric"
        ``ordinal_nvarchar`` <- reader.GetOrdinal "nvarchar"
        ``ordinal_real`` <- reader.GetOrdinal "real"
        ``ordinal_rowversion`` <- reader.GetOrdinal "rowversion"
        ``ordinal_smalldatetime`` <- reader.GetOrdinal "smalldatetime"
        ``ordinal_smallint`` <- reader.GetOrdinal "smallint"
        ``ordinal_smallmoney`` <- reader.GetOrdinal "smallmoney"
        ``ordinal_text`` <- reader.GetOrdinal "text"
        ``ordinal_time`` <- reader.GetOrdinal "time"
        ``ordinal_timestamp`` <- reader.GetOrdinal "timestamp"
        ``ordinal_tinyint`` <- reader.GetOrdinal "tinyint"
        ``ordinal_uniqueidentifier`` <- reader.GetOrdinal "uniqueidentifier"
        ``ordinal_varbinary`` <- reader.GetOrdinal "varbinary"
        ``ordinal_varchar`` <- reader.GetOrdinal "varchar"
        ``ordinal_xml`` <- reader.GetOrdinal "xml"

      let getItem (reader: SqlDataReader) =
        {|
          ``bigint`` = if reader.IsDBNull ``ordinal_bigint`` then None else reader.GetInt64 ``ordinal_bigint`` |> Some
          ``binary`` = if reader.IsDBNull ``ordinal_binary`` then None else reader.GetBytes ``ordinal_binary`` |> Some
          ``bit`` = if reader.IsDBNull ``ordinal_bit`` then None else reader.GetBoolean ``ordinal_bit`` |> Some
          ``char`` = if reader.IsDBNull ``ordinal_char`` then None else reader.GetString ``ordinal_char`` |> Some
          ``date`` = if reader.IsDBNull ``ordinal_date`` then None else reader.GetDateTime ``ordinal_date`` |> Some
          ``datetime`` = if reader.IsDBNull ``ordinal_datetime`` then None else reader.GetDateTime ``ordinal_datetime`` |> Some
          ``datetime2`` = if reader.IsDBNull ``ordinal_datetime2`` then None else reader.GetDateTime ``ordinal_datetime2`` |> Some
          ``datetimeoffset`` = if reader.IsDBNull ``ordinal_datetimeoffset`` then None else reader.GetDateTimeOffset ``ordinal_datetimeoffset`` |> Some
          ``decimal`` = if reader.IsDBNull ``ordinal_decimal`` then None else reader.GetDecimal ``ordinal_decimal`` |> Some
          ``float`` = if reader.IsDBNull ``ordinal_float`` then None else reader.GetDouble ``ordinal_float`` |> Some
          ``image`` = if reader.IsDBNull ``ordinal_image`` then None else reader.GetBytes ``ordinal_image`` |> Some
          ``int`` = if reader.IsDBNull ``ordinal_int`` then None else reader.GetInt32 ``ordinal_int`` |> Some
          ``money`` = if reader.IsDBNull ``ordinal_money`` then None else reader.GetDecimal ``ordinal_money`` |> Some
          ``nchar`` = if reader.IsDBNull ``ordinal_nchar`` then None else reader.GetString ``ordinal_nchar`` |> Some
          ``ntext`` = if reader.IsDBNull ``ordinal_ntext`` then None else reader.GetString ``ordinal_ntext`` |> Some
          ``numeric`` = if reader.IsDBNull ``ordinal_numeric`` then None else reader.GetDecimal ``ordinal_numeric`` |> Some
          ``nvarchar`` = if reader.IsDBNull ``ordinal_nvarchar`` then None else reader.GetString ``ordinal_nvarchar`` |> Some
          ``real`` = if reader.IsDBNull ``ordinal_real`` then None else reader.GetFloat ``ordinal_real`` |> Some
          ``rowversion`` = if reader.IsDBNull ``ordinal_rowversion`` then None else reader.GetBytes ``ordinal_rowversion`` |> Some
          ``smalldatetime`` = if reader.IsDBNull ``ordinal_smalldatetime`` then None else reader.GetDateTime ``ordinal_smalldatetime`` |> Some
          ``smallint`` = if reader.IsDBNull ``ordinal_smallint`` then None else reader.GetInt16 ``ordinal_smallint`` |> Some
          ``smallmoney`` = if reader.IsDBNull ``ordinal_smallmoney`` then None else reader.GetDecimal ``ordinal_smallmoney`` |> Some
          ``text`` = if reader.IsDBNull ``ordinal_text`` then None else reader.GetString ``ordinal_text`` |> Some
          ``time`` = if reader.IsDBNull ``ordinal_time`` then None else reader.GetTimeSpan ``ordinal_time`` |> Some
          ``timestamp`` = if reader.IsDBNull ``ordinal_timestamp`` then None else reader.GetBytes ``ordinal_timestamp`` |> Some
          ``tinyint`` = if reader.IsDBNull ``ordinal_tinyint`` then None else reader.GetByte ``ordinal_tinyint`` |> Some
          ``uniqueidentifier`` = if reader.IsDBNull ``ordinal_uniqueidentifier`` then None else reader.GetGuid ``ordinal_uniqueidentifier`` |> Some
          ``varbinary`` = if reader.IsDBNull ``ordinal_varbinary`` then None else reader.GetBytes ``ordinal_varbinary`` |> Some
          ``varchar`` = if reader.IsDBNull ``ordinal_varchar`` then None else reader.GetString ``ordinal_varchar`` |> Some
          ``xml`` = if reader.IsDBNull ``ordinal_xml`` then None else reader.GetString ``ordinal_xml`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithAllTypesNullExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithAllTypesNullExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithAllTypesNullExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``bigint``: int64 option,
          ``binary``: byte [] option,
          ``bit``: bool option,
          ``char``: string option,
          ``date``: DateTime option,
          ``datetime``: DateTime option,
          ``datetime2``: DateTime option,
          ``datetimeoffset``: DateTimeOffset option,
          ``decimal``: decimal option,
          ``float``: float option,
          ``image``: byte [] option,
          ``int``: int option,
          ``money``: decimal option,
          ``nchar``: string option,
          ``ntext``: string option,
          ``numeric``: decimal option,
          ``nvarchar``: string option,
          ``real``: float32 option,
          ``rowversion``: byte [] option,
          ``smalldatetime``: DateTime option,
          ``smallint``: int16 option,
          ``smallmoney``: decimal option,
          ``text``: string option,
          ``time``: TimeSpan option,
          ``timestamp``: byte [] option,
          ``tinyint``: byte option,
          ``uniqueidentifier``: Guid option,
          ``varbinary``: byte [] option,
          ``varchar``: string option,
          ``xml``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = Option.toDbNull ``bigint``)
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull ``binary``)
            SqlParameter("@bit", SqlDbType.Bit, Value = Option.toDbNull ``bit``)
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = Option.toDbNull ``char``)
            SqlParameter("@date", SqlDbType.Date, Value = Option.toDbNull ``date``)
            SqlParameter("@datetime", SqlDbType.DateTime, Value = Option.toDbNull ``datetime``)
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull ``datetime2``)
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull ``datetimeoffset``)
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull ``decimal``)
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = Option.toDbNull ``float``)
            SqlParameter("@image", SqlDbType.Image, Value = Option.toDbNull ``image``)
            SqlParameter("@int", SqlDbType.Int, Value = Option.toDbNull ``int``)
            SqlParameter("@money", SqlDbType.Money, Value = Option.toDbNull ``money``)
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull ``nchar``)
            SqlParameter("@ntext", SqlDbType.NText, Value = Option.toDbNull ``ntext``)
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull ``numeric``)
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull ``nvarchar``)
            SqlParameter("@real", SqlDbType.Real, Value = Option.toDbNull ``real``)
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = Option.toDbNull ``rowversion``)
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull ``smalldatetime``)
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = Option.toDbNull ``smallint``)
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull ``smallmoney``)
            SqlParameter("@text", SqlDbType.Text, Value = Option.toDbNull ``text``)
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = Option.toDbNull ``time``)
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = Option.toDbNull ``timestamp``)
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = Option.toDbNull ``tinyint``)
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull ``uniqueidentifier``)
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull ``varbinary``)
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull ``varchar``)
            SqlParameter("@xml", SqlDbType.Xml, Value = Option.toDbNull ``xml``)
          |]
        ``ProcWithAllTypesNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@bigint", SqlDbType.BigInt, Value = Option.toDbNull (^a: (member ``Bigint``: int64 option) dto))
            SqlParameter("@binary", SqlDbType.Binary, Size = 42, Value = Option.toDbNull (^a: (member ``Binary``: byte [] option) dto))
            SqlParameter("@bit", SqlDbType.Bit, Value = Option.toDbNull (^a: (member ``Bit``: bool option) dto))
            SqlParameter("@char", SqlDbType.Char, Size = 42, Value = Option.toDbNull (^a: (member ``Char``: string option) dto))
            SqlParameter("@date", SqlDbType.Date, Value = Option.toDbNull (^a: (member ``Date``: DateTime option) dto))
            SqlParameter("@datetime", SqlDbType.DateTime, Value = Option.toDbNull (^a: (member ``Datetime``: DateTime option) dto))
            SqlParameter("@datetime2", SqlDbType.DateTime2, Size = 7, Value = Option.toDbNull (^a: (member ``Datetime2``: DateTime option) dto))
            SqlParameter("@datetimeoffset", SqlDbType.DateTimeOffset, Size = 8, Value = Option.toDbNull (^a: (member ``Datetimeoffset``: DateTimeOffset option) dto))
            SqlParameter("@decimal", SqlDbType.Decimal, Precision = 10uy, Scale = 5uy, Value = Option.toDbNull (^a: (member ``Decimal``: decimal option) dto))
            SqlParameter("@float", SqlDbType.Float, Size = 8, Value = Option.toDbNull (^a: (member ``Float``: float option) dto))
            SqlParameter("@image", SqlDbType.Image, Value = Option.toDbNull (^a: (member ``Image``: byte [] option) dto))
            SqlParameter("@int", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Int``: int option) dto))
            SqlParameter("@money", SqlDbType.Money, Value = Option.toDbNull (^a: (member ``Money``: decimal option) dto))
            SqlParameter("@nchar", SqlDbType.NChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nchar``: string option) dto))
            SqlParameter("@ntext", SqlDbType.NText, Value = Option.toDbNull (^a: (member ``Ntext``: string option) dto))
            SqlParameter("@numeric", SqlDbType.Decimal, Precision = 8uy, Scale = 3uy, Value = Option.toDbNull (^a: (member ``Numeric``: decimal option) dto))
            SqlParameter("@nvarchar", SqlDbType.NVarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Nvarchar``: string option) dto))
            SqlParameter("@real", SqlDbType.Real, Value = Option.toDbNull (^a: (member ``Real``: float32 option) dto))
            SqlParameter("@rowversion", SqlDbType.Timestamp, Value = Option.toDbNull (^a: (member ``Rowversion``: byte [] option) dto))
            SqlParameter("@smalldatetime", SqlDbType.SmallDateTime, Value = Option.toDbNull (^a: (member ``Smalldatetime``: DateTime option) dto))
            SqlParameter("@smallint", SqlDbType.SmallInt, Value = Option.toDbNull (^a: (member ``Smallint``: int16 option) dto))
            SqlParameter("@smallmoney", SqlDbType.SmallMoney, Value = Option.toDbNull (^a: (member ``Smallmoney``: decimal option) dto))
            SqlParameter("@text", SqlDbType.Text, Value = Option.toDbNull (^a: (member ``Text``: string option) dto))
            SqlParameter("@time", SqlDbType.Time, Size = 3, Value = Option.toDbNull (^a: (member ``Time``: TimeSpan option) dto))
            SqlParameter("@timestamp", SqlDbType.Timestamp, Value = Option.toDbNull (^a: (member ``Timestamp``: byte [] option) dto))
            SqlParameter("@tinyint", SqlDbType.TinyInt, Value = Option.toDbNull (^a: (member ``Tinyint``: byte option) dto))
            SqlParameter("@uniqueidentifier", SqlDbType.UniqueIdentifier, Value = Option.toDbNull (^a: (member ``Uniqueidentifier``: Guid option) dto))
            SqlParameter("@varbinary", SqlDbType.VarBinary, Size = 42, Value = Option.toDbNull (^a: (member ``Varbinary``: byte [] option) dto))
            SqlParameter("@varchar", SqlDbType.VarChar, Size = 42, Value = Option.toDbNull (^a: (member ``Varchar``: string option) dto))
            SqlParameter("@xml", SqlDbType.Xml, Value = Option.toDbNull (^a: (member ``Xml``: string option) dto))
          |]
        ``ProcWithAllTypesNullExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    type ``ProcWithMultipleColumnsAndNoParams`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndNoParams"
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetString ``ordinal_Bar``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndNoParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndNoParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    type ``ProcWithMultipleColumnsAndNoParamsExtended`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndNoParamsExtended"
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetString ``ordinal_Bar``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndNoParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndNoParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleDefaultParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleDefaultParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithMultipleColumnsAndSimpleDefaultParams`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleDefaultParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndSimpleDefaultParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int,
          ``bar``: string
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleDefaultParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Bar``: string) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleDefaultParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleDefaultParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int,
          ``bar``: string
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Bar``: string) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleDefaultParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleNonDefaultParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleNonDefaultParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithMultipleColumnsAndSimpleNonDefaultParams`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndSimpleNonDefaultParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int,
          ``bar``: string
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Bar``: string) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int,
          ``bar``: string
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = (^a: (member ``Bar``: string) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleNonDefaultParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleNullParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleNullParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithMultipleColumnsAndSimpleNullParams`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleNullParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndSimpleNullParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int option,
          ``bar``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleNullParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Foo``: int option) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Bar``: string option) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleNullParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndSimpleNullParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndSimpleNullParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithMultipleColumnsAndSimpleNullParamsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndSimpleNullParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndSimpleNullParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int option,
          ``bar``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull ``foo``)
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``bar``)
          |]
        ``ProcWithMultipleColumnsAndSimpleNullParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Foo``: int option) dto))
            SqlParameter("@bar", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Bar``: string option) dto))
          |]
        ``ProcWithMultipleColumnsAndSimpleNullParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndTvpParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndTvpParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetString ``ordinal_Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithMultipleColumnsAndTvpParams`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndTvpParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndTvpParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``single``: seq<TableTypes.``dbo``.``SingleColNonNull``>,
          ``multi``: seq<TableTypes.``dbo``.``MultiColNonNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = ``single``)
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNonNull", Value = ``multi``)
          |]
        ``ProcWithMultipleColumnsAndTvpParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = (^a: (member ``Single``: #seq<TableTypes.``dbo``.``SingleColNonNull``>) dto))
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNonNull", Value = (^a: (member ``Multi``: #seq<TableTypes.``dbo``.``MultiColNonNull``>) dto))
          |]
        ``ProcWithMultipleColumnsAndTvpParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleColumnsAndTvpParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleColumnsAndTvpParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetString ``ordinal_Bar``
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithMultipleColumnsAndTvpParamsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleColumnsAndTvpParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleColumnsAndTvpParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``single``: seq<TableTypes.``dbo``.``SingleColNonNull``>,
          ``multi``: seq<TableTypes.``dbo``.``MultiColNonNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = ``single``)
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNonNull", Value = ``multi``)
          |]
        ``ProcWithMultipleColumnsAndTvpParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNonNull", Value = (^a: (member ``Single``: #seq<TableTypes.``dbo``.``SingleColNonNull``>) dto))
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNonNull", Value = (^a: (member ``Multi``: #seq<TableTypes.``dbo``.``MultiColNonNull``>) dto))
          |]
        ``ProcWithMultipleColumnsAndTvpParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleNullableColumnsAndTvpParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleNullableColumnsAndTvpParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithMultipleNullableColumnsAndTvpParams`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleNullableColumnsAndTvpParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleNullableColumnsAndTvpParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``single``: seq<TableTypes.``dbo``.``SingleColNull``>,
          ``multi``: seq<TableTypes.``dbo``.``MultiColNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNull", Value = ``single``)
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = ``multi``)
          |]
        ``ProcWithMultipleNullableColumnsAndTvpParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNull", Value = (^a: (member ``Single``: #seq<TableTypes.``dbo``.``SingleColNull``>) dto))
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = (^a: (member ``Multi``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
          |]
        ``ProcWithMultipleNullableColumnsAndTvpParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithMultipleNullableColumnsAndTvpParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithMultipleNullableColumnsAndTvpParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
          ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithMultipleNullableColumnsAndTvpParamsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithMultipleNullableColumnsAndTvpParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithMultipleNullableColumnsAndTvpParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``single``: seq<TableTypes.``dbo``.``SingleColNull``>,
          ``multi``: seq<TableTypes.``dbo``.``MultiColNull``>
        ) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNull", Value = ``single``)
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = ``multi``)
          |]
        ``ProcWithMultipleNullableColumnsAndTvpParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@single", SqlDbType.Structured, TypeName = "dbo.SingleColNull", Value = (^a: (member ``Single``: #seq<TableTypes.``dbo``.``SingleColNull``>) dto))
            SqlParameter("@multi", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = (^a: (member ``Multi``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
          |]
        ``ProcWithMultipleNullableColumnsAndTvpParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithNoResults_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithNoResults"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd


    type ``ProcWithNoResults`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithNoResults``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithNoResults``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
          |]
        ``ProcWithNoResults_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
          |]
        ``ProcWithNoResults_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithNoResultsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithNoResultsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd


    type ``ProcWithNoResultsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithNoResultsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithNoResultsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
          |]
        ``ProcWithNoResultsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
          |]
        ``ProcWithNoResultsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    type ``ProcWithNonFSharpFriendlyNames`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithNonFSharpFriendlyNames"
        userConfigureCmd cmd

      let mutable ``ordinal_This is the first column`` = 0
      let mutable ``ordinal_!"#%&/()=?`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_This is the first column`` <- reader.GetOrdinal "This is the first column"
        ``ordinal_!"#%&/()=?`` <- reader.GetOrdinal "!\"#%&/()=?"

      let getItem (reader: SqlDataReader) =
        {|
          ``This is the first column`` = reader.GetString ``ordinal_This is the first column``
          ``!"#%&/()=?`` = reader.GetInt32 ``ordinal_!"#%&/()=?``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithNonFSharpFriendlyNames``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithNonFSharpFriendlyNames``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    type ``ProcWithNonFSharpFriendlyNamesExtended`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithNonFSharpFriendlyNamesExtended"
        userConfigureCmd cmd

      let mutable ``ordinal_This is the first column`` = 0
      let mutable ``ordinal_!"#%&/()=?`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_This is the first column`` <- reader.GetOrdinal "This is the first column"
        ``ordinal_!"#%&/()=?`` <- reader.GetOrdinal "!\"#%&/()=?"

      let getItem (reader: SqlDataReader) =
        {|
          ``This is the first column`` = reader.GetString ``ordinal_This is the first column``
          ``!"#%&/()=?`` = reader.GetInt32 ``ordinal_!"#%&/()=?``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithNonFSharpFriendlyNamesExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithNonFSharpFriendlyNamesExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd
        |> wrapResultWithOutParams


    type ``ProcWithOutParams`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithOutParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
          |]
        ``ProcWithOutParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
          |]
        ``ProcWithOutParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParamsAndRetVal_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParamsAndRetVal"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
          ReturnValue = sqlParams.[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd
        |> wrapResultWithOutParams


    type ``ProcWithOutParamsAndRetVal`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParamsAndRetVal``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithOutParamsAndRetVal``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParamsAndRetValExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParamsAndRetValExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
          ReturnValue = sqlParams.[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd
        |> wrapResultWithOutParams


    type ``ProcWithOutParamsAndRetValExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParamsAndRetValExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithOutParamsAndRetValExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParamsAndRetValVoption_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParamsAndRetValVoption"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then ValueNone else sqlParams.[1].Value |> unbox<int> |> ValueSome
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then ValueNone else sqlParams.[3].Value |> unbox<string> |> ValueSome
            |}
          ReturnValue = sqlParams.[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd
        |> wrapResultWithOutParams


    type ``ProcWithOutParamsAndRetValVoption`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParamsAndRetValVoption``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithOutParamsAndRetValVoption``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string voption
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map ValueOption.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetValVoption_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = ValueOption.toDbNull (^a: (member ``Out1``: int voption) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = ValueOption.toDbNull (^a: (member ``Out2``: string voption) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithOutParamsAndRetValVoption_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOutParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOutParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd
        |> wrapResultWithOutParams


    type ``ProcWithOutParamsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOutParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithOutParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
          |]
        ``ProcWithOutParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
          |]
        ``ProcWithOutParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithOverriddenDtoParamName_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithOverriddenDtoParamName"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithOverriddenDtoParamName`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithOverriddenDtoParamName``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithOverriddenDtoParamName``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``nameToBeOverridden``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@nameToBeOverridden", SqlDbType.Int, Value = ``nameToBeOverridden``)
          |]
        ``ProcWithOverriddenDtoParamName_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@nameToBeOverridden", SqlDbType.Int, Value = (^a: (member ``newDtoParamName``: int) dto))
          |]
        ``ProcWithOverriddenDtoParamName_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndOutParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndOutParams"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        |}

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem
        |> wrapResultWithOutParams

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem
        |> wrapResultWithOutParams


    type ``ProcWithResultsAndOutParams`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndOutParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithResultsAndOutParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
          |]
        ``ProcWithResultsAndOutParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
          |]
        ``ProcWithResultsAndOutParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndOutParamsAndRetVal_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndOutParamsAndRetVal"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        |}

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
          ReturnValue = sqlParams.[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem
        |> wrapResultWithOutParams

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem
        |> wrapResultWithOutParams


    type ``ProcWithResultsAndOutParamsAndRetVal`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndOutParamsAndRetVal``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithResultsAndOutParamsAndRetVal``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndOutParamsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndOutParamsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndOutParamsAndRetValExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndOutParamsAndRetValExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        |}

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
          ReturnValue = sqlParams.[5].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem
        |> wrapResultWithOutParams

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem
        |> wrapResultWithOutParams


    type ``ProcWithResultsAndOutParamsAndRetValExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndOutParamsAndRetValExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithResultsAndOutParamsAndRetValExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ``baseRetVal``: int,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndOutParamsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndOutParamsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndOutParamsExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndOutParamsExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        |}

      let wrapResultWithOutParams result =
        {|
          Result = result
          Out =
            {|
              ``out1`` = if sqlParams.[1].Value = box DBNull.Value then None else sqlParams.[1].Value |> unbox<int> |> Some
              ``out2`` = if sqlParams.[3].Value = box DBNull.Value then None else sqlParams.[3].Value |> unbox<string> |> Some
            |}
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem
        |> wrapResultWithOutParams

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem
        |> wrapResultWithOutParams


    type ``ProcWithResultsAndOutParamsExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndOutParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithResultsAndOutParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``setOut1``: bool,
          ``setOut2``: bool,
          ?``out1``: int,
          ?``out2``: string option
        ) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = ``setOut1``)
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = (``out1`` |> Option.map box |> Option.defaultValue (box DBNull.Value)))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = ``setOut2``)
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = (``out2`` |> Option.map Option.toDbNull |> Option.defaultValue (box DBNull.Value)))
          |]
        ``ProcWithResultsAndOutParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@setOut1", SqlDbType.Bit, Value = (^a: (member ``SetOut1``: bool) dto))
            SqlParameter("@out1", SqlDbType.Int, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out1``: int option) dto))
            SqlParameter("@setOut2", SqlDbType.Bit, Value = (^a: (member ``SetOut2``: bool) dto))
            SqlParameter("@out2", SqlDbType.NVarChar, Size = 50, Direction = ParameterDirection.InputOutput, Value = Option.toDbNull (^a: (member ``Out2``: string option) dto))
          |]
        ``ProcWithResultsAndOutParamsExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndRetVal_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndRetVal"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        |}

      let wrapResultWithOutParams result =
        {|
          Result = result
          ReturnValue = sqlParams.[1].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem
        |> wrapResultWithOutParams

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem
        |> wrapResultWithOutParams


    type ``ProcWithResultsAndRetVal`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndRetVal``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithResultsAndRetVal``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``baseRetVal``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithResultsAndRetValExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithResultsAndRetValExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_Foo`` = 0
      let mutable ``ordinal_Bar`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
        ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

      let getItem (reader: SqlDataReader) =
        {|
          ``Foo`` = reader.GetInt32 ``ordinal_Foo``
          ``Bar`` = reader.GetInt32 ``ordinal_Bar``
        |}

      let wrapResultWithOutParams result =
        {|
          Result = result
          ReturnValue = sqlParams.[1].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem
        |> wrapResultWithOutParams

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem
        |> wrapResultWithOutParams


    type ``ProcWithResultsAndRetValExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithResultsAndRetValExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithResultsAndRetValExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``baseRetVal``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithResultsAndRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithRetVal_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithRetVal"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams result =
        {|
          Result = result
          ReturnValue = sqlParams.[1].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd
        |> wrapResultWithOutParams


    type ``ProcWithRetVal`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithRetVal``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithRetVal``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``baseRetVal``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithRetVal_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithRetValExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithRetValExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let wrapResultWithOutParams result =
        {|
          Result = result
          ReturnValue = sqlParams.[1].Value |> unbox<int>
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeNonQueryAsync connStr conn configureConn configureCmd (defaultArg cancellationToken CancellationToken.None)
        |> Task.map wrapResultWithOutParams

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeNonQuery connStr conn configureConn configureCmd
        |> wrapResultWithOutParams


    type ``ProcWithRetValExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithRetValExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithRetValExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``baseRetVal``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = ``baseRetVal``)
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@baseRetVal", SqlDbType.Int, Value = (^a: (member ``BaseRetVal``: int) dto))
            SqlParameter("ReturnValue", SqlDbType.Int, Direction = ParameterDirection.ReturnValue)
          |]
        ``ProcWithRetValExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    type ``ProcWithSingleColumnAndNoParams`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleColumnAndNoParams"
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        reader.GetInt32 0

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleColumnAndNoParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleColumnAndNoParams``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    type ``ProcWithSingleColumnAndNoParamsExtended`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleColumnAndNoParamsExtended"
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        reader.GetInt32 0

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleColumnAndNoParamsExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleColumnAndNoParamsExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    type ``ProcWithSingleNamelessColumn`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNamelessColumn"
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        reader.GetInt32 0

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNamelessColumn``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleNamelessColumn``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    type ``ProcWithSingleNamelessColumnExtended`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNamelessColumnExtended"
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        reader.GetInt32 0

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNamelessColumnExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleNamelessColumnExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSingleNonNullColumn_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNonNullColumn"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithSingleNonNullColumn`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNonNullColumn``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleNonNullColumn``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
          |]
        ``ProcWithSingleNonNullColumn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
          |]
        ``ProcWithSingleNonNullColumn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSingleNonNullColumnExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNonNullColumnExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithSingleNonNullColumnExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNonNullColumnExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleNonNullColumnExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = ``foo``)
          |]
        ``ProcWithSingleNonNullColumnExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = (^a: (member ``Foo``: int) dto))
          |]
        ``ProcWithSingleNonNullColumnExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSingleNullColumn_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNullColumn"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithSingleNullColumn`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNullColumn``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleNullColumn``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int option
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull ``foo``)
          |]
        ``ProcWithSingleNullColumn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Foo``: int option) dto))
          |]
        ``ProcWithSingleNullColumn_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSingleNullColumnExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleNullColumnExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let initOrdinals = ignore<SqlDataReader>

      let getItem (reader: SqlDataReader) =
        if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithSingleNullColumnExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleNullColumnExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleNullColumnExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``foo``: int option
        ) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull ``foo``)
          |]
        ``ProcWithSingleNullColumnExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@foo", SqlDbType.Int, Value = Option.toDbNull (^a: (member ``Foo``: int option) dto))
          |]
        ``ProcWithSingleNullColumnExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    type ``ProcWithSingleRecordCol`` private (connStr: string, conn: SqlConnection) =

      let configureCmd userConfigureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSingleRecordCol"
        userConfigureCmd cmd

      let mutable ``ordinal_Test`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_Test`` <- reader.GetOrdinal "Test"

      let getItem (reader: SqlDataReader) =
        {|
          ``Test`` = reader.GetInt32 ``ordinal_Test``
        |}

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSingleRecordCol``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSingleRecordCol``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member this.Execute() =
        executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member this.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member this.LazyExecute() =
        executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

      member this.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member this.ExecuteSingle() =
        executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSpecialCasing_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSpecialCasing"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_COL1`` = 0
      let mutable ``ordinal_Col2`` = 0
      let mutable ``ordinal_col3`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_COL1`` <- reader.GetOrdinal "COL1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"
        ``ordinal_col3`` <- reader.GetOrdinal "col3"

      let getItem (reader: SqlDataReader) =
        {|
          ``COL1`` = if reader.IsDBNull ``ordinal_COL1`` then None else reader.GetInt32 ``ordinal_COL1`` |> Some
          ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
          ``col3`` = if reader.IsDBNull ``ordinal_col3`` then None else reader.GetInt32 ``ordinal_col3`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithSpecialCasing`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSpecialCasing``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSpecialCasing``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``PARAM1``: int,
          ``Param2``: int,
          ``param3``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@PARAM1", SqlDbType.Int, Value = ``PARAM1``)
            SqlParameter("@Param2", SqlDbType.Int, Value = ``Param2``)
            SqlParameter("@param3", SqlDbType.Int, Value = ``param3``)
          |]
        ``ProcWithSpecialCasing_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@PARAM1", SqlDbType.Int, Value = (^a: (member ``PARAM1``: int) dto))
            SqlParameter("@Param2", SqlDbType.Int, Value = (^a: (member ``Param2``: int) dto))
            SqlParameter("@param3", SqlDbType.Int, Value = (^a: (member ``Param3``: int) dto))
          |]
        ``ProcWithSpecialCasing_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


    [<EditorBrowsable(EditorBrowsableState.Never)>]
    type ``ProcWithSpecialCasingExtended_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

      let configureCmd (cmd: SqlCommand) =
        cmd.CommandType <- CommandType.StoredProcedure
        cmd.CommandText <- "dbo.ProcWithSpecialCasingExtended"
        cmd.Parameters.AddRange sqlParams
        userConfigureCmd cmd

      let mutable ``ordinal_COL1`` = 0
      let mutable ``ordinal_Col2`` = 0
      let mutable ``ordinal_col3`` = 0

      let initOrdinals (reader: SqlDataReader) =
        ``ordinal_COL1`` <- reader.GetOrdinal "COL1"
        ``ordinal_Col2`` <- reader.GetOrdinal "Col2"
        ``ordinal_col3`` <- reader.GetOrdinal "col3"

      let getItem (reader: SqlDataReader) =
        {|
          ``COL1`` = if reader.IsDBNull ``ordinal_COL1`` then None else reader.GetInt32 ``ordinal_COL1`` |> Some
          ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
          ``col3`` = if reader.IsDBNull ``ordinal_col3`` then None else reader.GetInt32 ``ordinal_col3`` |> Some
        |}

      member _.ExecuteAsync(?cancellationToken) =
        executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecute() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteWithSyncRead() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
        }

      member _.Execute() =
        executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

      #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

      member _.LazyExecuteAsync(?cancellationToken) =
        executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
        executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      #endif

      member _.LazyExecute() =
        executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

      member _.ExecuteSingleAsync(?cancellationToken) =
        executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

      member this.AsyncExecuteSingle() =
        async {
          let! ct = Async.CancellationToken
          return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
        }

      member _.ExecuteSingle() =
        executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


    type ``ProcWithSpecialCasingExtended`` private (connStr: string, conn: SqlConnection) =

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val connStr = connStr

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val conn = conn

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val configureConn : SqlConnection -> unit = ignore with get, set

      [<EditorBrowsable(EditorBrowsableState.Never)>]
      member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

      member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
        this.userConfigureCmd <- configureCommand
        this

      static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
        ``ProcWithSpecialCasingExtended``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

      static member WithConnection(connection) = ``ProcWithSpecialCasingExtended``(null, connection)

      member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
        match configureConnection with
        | None -> ()
        | Some config -> this.configureConn <- config
        this

      member this.WithParameters
        (
          ``PARAM1``: int,
          ``Param2``: int,
          ``param3``: int
        ) =
        let sqlParams =
          [|
            SqlParameter("@PARAM1", SqlDbType.Int, Value = ``PARAM1``)
            SqlParameter("@Param2", SqlDbType.Int, Value = ``Param2``)
            SqlParameter("@param3", SqlDbType.Int, Value = ``param3``)
          |]
        ``ProcWithSpecialCasingExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

      member inline this.WithParameters(dto: ^a) =
        let sqlParams =
          [|
            SqlParameter("@PARAM1", SqlDbType.Int, Value = (^a: (member ``PARAM1``: int) dto))
            SqlParameter("@Param2", SqlDbType.Int, Value = (^a: (member ``Param2``: int) dto))
            SqlParameter("@param3", SqlDbType.Int, Value = (^a: (member ``Param3``: int) dto))
          |]
        ``ProcWithSpecialCasingExtended_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


module Scripts =


  module ``SQL`` =


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``DynamicSqlWithDeclaration_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

        let configureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            DECLARE @_col1Filter NVARCHAR(42) = @col1Filter

            DECLARE @sql NVARCHAR(MAX) =
              'SELECT * FROM dbo.Table1 WHERE TableCol1 = @col1Filter'

            DECLARE @paramList NVARCHAR(MAX) =
              '@col1Filter NVARCHAR(42)'

            EXEC sp_executesql @sql, @paramList, @_col1Filter

          """
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let mutable ``ordinal_TableCol1`` = 0
        let mutable ``ordinal_TableCol2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
          ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

        let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
          {
            ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
            ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
          }

        member _.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member _.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        #endif

        member _.LazyExecute() =
          executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

        member _.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


      type ``DynamicSqlWithDeclaration`` private (connStr: string, conn: SqlConnection) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``DynamicSqlWithDeclaration``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``DynamicSqlWithDeclaration``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``col1Filter``: string
          ) =
          let sqlParams =
            [|
              SqlParameter("@col1Filter", SqlDbType.NVarChar, Size = 42, Value = ``col1Filter``)
            |]
          ``DynamicSqlWithDeclaration_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

        member inline this.WithParameters(dto: ^a) =
          let sqlParams =
            [|
              SqlParameter("@col1Filter", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Col1Filter``: string) dto))
            |]
          ``DynamicSqlWithDeclaration_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``DynamicSqlWithoutDeclaration_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

        let configureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            DECLARE @sql NVARCHAR(MAX) =
              'SELECT * FROM dbo.Table1 WHERE TableCol1 = @col1Filter'

            DECLARE @paramList NVARCHAR(MAX) =
              '@col1Filter NVARCHAR(42)'

            EXEC sp_executesql @sql, @paramList, @col1Filter

          """
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let mutable ``ordinal_TableCol1`` = 0
        let mutable ``ordinal_TableCol2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
          ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

        let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
          {
            ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
            ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
          }

        member _.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member _.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        #endif

        member _.LazyExecute() =
          executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

        member _.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


      type ``DynamicSqlWithoutDeclaration`` private (connStr: string, conn: SqlConnection) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``DynamicSqlWithoutDeclaration``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``DynamicSqlWithoutDeclaration``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``col1Filter``: string
          ) =
          let sqlParams =
            [|
              SqlParameter("@col1Filter", SqlDbType.NVarChar, Size = 42, Value = ``col1Filter``)
            |]
          ``DynamicSqlWithoutDeclaration_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

        member inline this.WithParameters(dto: ^a) =
          let sqlParams =
            [|
              SqlParameter("@col1Filter", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Col1Filter``: string) dto))
            |]
          ``DynamicSqlWithoutDeclaration_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``NormalParams_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

        let configureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT * FROM Table1 WHERE TableCol1 = @col1

          """
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let mutable ``ordinal_TableCol1`` = 0
        let mutable ``ordinal_TableCol2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
          ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

        let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
          {
            ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
            ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
          }

        member _.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member _.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        #endif

        member _.LazyExecute() =
          executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

        member _.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


      type ``NormalParams`` private (connStr: string, conn: SqlConnection) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``NormalParams``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``NormalParams``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``col1``: string
          ) =
          let sqlParams =
            [|
              SqlParameter("@col1", SqlDbType.NVarChar, Size = 42, Value = ``col1``)
            |]
          ``NormalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

        member inline this.WithParameters(dto: ^a) =
          let sqlParams =
            [|
              SqlParameter("@col1", SqlDbType.NVarChar, Size = 42, Value = (^a: (member ``Col1``: string) dto))
            |]
          ``NormalParams_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``OverriddenDtoParamName_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

        let configureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT @nameToBeOverridden

          """
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let initOrdinals = ignore<SqlDataReader>

        let getItem (reader: SqlDataReader) =
          if reader.IsDBNull 0 then None else reader.GetInt32 0 |> Some

        member _.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member _.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        #endif

        member _.LazyExecute() =
          executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

        member _.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


      type ``OverriddenDtoParamName`` private (connStr: string, conn: SqlConnection) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``OverriddenDtoParamName``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``OverriddenDtoParamName``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``nameToBeOverridden``: int
          ) =
          let sqlParams =
            [|
              SqlParameter("@nameToBeOverridden", SqlDbType.Int, Value = ``nameToBeOverridden``)
            |]
          ``OverriddenDtoParamName_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

        member inline this.WithParameters(dto: ^a) =
          let sqlParams =
            [|
              SqlParameter("@nameToBeOverridden", SqlDbType.Int, Value = (^a: (member ``newDtoParamName``: int) dto))
            |]
          ``OverriddenDtoParamName_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``ParamsUsedTwice_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

        let configureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT * FROM Table1 WHERE TableCol1 = @col1 AND TableCol1 = @col1

          """
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let mutable ``ordinal_TableCol1`` = 0
        let mutable ``ordinal_TableCol2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
          ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

        let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
          {
            ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
            ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
          }

        member _.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member _.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        #endif

        member _.LazyExecute() =
          executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

        member _.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


      type ``ParamsUsedTwice`` private (connStr: string, conn: SqlConnection) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``ParamsUsedTwice``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``ParamsUsedTwice``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``col1``: string option
          ) =
          let sqlParams =
            [|
              SqlParameter("@col1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``col1``)
            |]
          ``ParamsUsedTwice_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

        member inline this.WithParameters(dto: ^a) =
          let sqlParams =
            [|
              SqlParameter("@col1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Col1``: string option) dto))
            |]
          ``ParamsUsedTwice_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


      type ``SelectAllFromTable`` private (connStr: string, conn: SqlConnection) =

        let configureCmd userConfigureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT * FROM Table1

          """
          userConfigureCmd cmd

        let mutable ``ordinal_TableCol1`` = 0
        let mutable ``ordinal_TableCol2`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
          ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

        let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
          {
            ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
            ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
          }

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``SelectAllFromTable``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``SelectAllFromTable``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member this.Execute() =
          executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member this.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        #endif

        member this.LazyExecute() =
          executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

        member this.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteSingle() =
          executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


      type ``SingleRecordCol`` private (connStr: string, conn: SqlConnection) =

        let configureCmd userConfigureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT Test = 1

          """
          userConfigureCmd cmd

        let mutable ``ordinal_Test`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Test`` <- reader.GetOrdinal "Test"

        let getItem (reader: SqlDataReader) =
          {|
            ``Test`` = reader.GetInt32 ``ordinal_Test``
          |}

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``SingleRecordCol``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``SingleRecordCol``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member this.Execute() =
          executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member this.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        #endif

        member this.LazyExecute() =
          executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

        member this.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteSingle() =
          executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``TempTable_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter [], tempTabledata : obj[] seq) =

        let configureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            CREATE TABLE #Temp (Id INT NOT NULL, [Name] NVARCHAR(100) NOT NULL)
          """
          cmd.ExecuteNonQuery() |> ignore

          use reader = new TempTableLoader(2, tempTabledata)
          use bulkCopy = new SqlBulkCopy(cmd.Connection)
          bulkCopy.BulkCopyTimeout <- 0
          bulkCopy.BatchSize <- 5000
          bulkCopy.DestinationTableName <- "#Temp"
          bulkCopy.WriteToServer(reader)
          cmd.CommandText <- """
            SELECT Id, [Name] FROM #Temp

          """
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let mutable ``ordinal_Id`` = 0
        let mutable ``ordinal_Name`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Id`` <- reader.GetOrdinal "Id"
          ``ordinal_Name`` <- reader.GetOrdinal "Name"

        let getItem (reader: SqlDataReader) =
          {|
            ``Id`` = reader.GetInt32 ``ordinal_Id``
            ``Name`` = reader.GetString ``ordinal_Name``
          |}

        member _.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member _.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        #endif

        member _.LazyExecute() =
          executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

        member _.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem

      type ``TempTabledata`` (Id : int, Name : string) =
        member val values = [| box Id; box Name |]


      type ``TempTable`` private (connStr: string, conn: SqlConnection) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``TempTable``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``TempTable``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``data`` : TempTabledata seq
          ) =
          let sqlParams =
            [|
            |]
          let tempTabledata = ``data`` |> Seq.map(fun row -> row.values)
          ``TempTable_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTabledata)

        member inline this.WithParameters(dto: ^a) =
          let sqlParams =
            [|
            |]
          let tempTabledata = 
            (^a: (member ``data``: _) dto)
            |> Seq.map(fun (row : ^b) ->
              [|
                box (^b: (member ``Id``: int) row)
                box (^b: (member ``Name``: string) row)
              |]
            )
          ``TempTable_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams, tempTabledata)


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``UserDefinedTableType_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

        let configureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """
            SELECT * FROM @tvp

          """
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        let mutable ``ordinal_Foo`` = 0
        let mutable ``ordinal_Bar`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
          ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

        let getItem (reader: SqlDataReader) =
          {|
            ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
            ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
          |}

        member _.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

        #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

        member _.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        #endif

        member _.LazyExecute() =
          executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

        member _.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member _.ExecuteSingle() =
          executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


      type ``UserDefinedTableType`` private (connStr: string, conn: SqlConnection) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``UserDefinedTableType``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection) = ``UserDefinedTableType``(null, connection)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``tvp``: seq<TableTypes.``dbo``.``MultiColNull``>
          ) =
          let sqlParams =
            [|
              SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = ``tvp``)
            |]
          ``UserDefinedTableType_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

        member inline this.WithParameters(dto: ^a) =
          let sqlParams =
            [|
              SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
            |]
          ``UserDefinedTableType_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


      module ``Option`` =


          [<EditorBrowsable(EditorBrowsableState.Never)>]
          type ``In_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

            let configureCmd (cmd: SqlCommand) =
              cmd.CommandText <- """
                SELECT @param1

              """
              cmd.Parameters.AddRange sqlParams
              userConfigureCmd cmd

            let initOrdinals = ignore<SqlDataReader>

            let getItem (reader: SqlDataReader) =
              if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

            member _.ExecuteAsync(?cancellationToken) =
              executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecute() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsync(ct) |> Async.AwaitTask
              }

            member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteWithSyncRead() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
              }

            member _.Execute() =
              executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

            #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

            member _.LazyExecuteAsync(?cancellationToken) =
              executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            #endif

            member _.LazyExecute() =
              executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

            member _.ExecuteSingleAsync(?cancellationToken) =
              executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteSingle() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
              }

            member _.ExecuteSingle() =
              executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


          type ``In`` private (connStr: string, conn: SqlConnection) =

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val connStr = connStr

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val conn = conn

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val configureConn : SqlConnection -> unit = ignore with get, set

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

            member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
              this.userConfigureCmd <- configureCommand
              this

            static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
              ``In``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

            static member WithConnection(connection) = ``In``(null, connection)

            member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
              match configureConnection with
              | None -> ()
              | Some config -> this.configureConn <- config
              this

            member this.WithParameters
              (
                ``param1``: string option
              ) =
              let sqlParams =
                [|
                  SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
                |]
              ``In_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

            member inline this.WithParameters(dto: ^a) =
              let sqlParams =
                [|
                  SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
                |]
              ``In_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


          [<EditorBrowsable(EditorBrowsableState.Never)>]
          type ``Out_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

            let configureCmd (cmd: SqlCommand) =
              cmd.CommandText <- """
                SELECT @param1

              """
              cmd.Parameters.AddRange sqlParams
              userConfigureCmd cmd

            let initOrdinals = ignore<SqlDataReader>

            let getItem (reader: SqlDataReader) =
              if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

            member _.ExecuteAsync(?cancellationToken) =
              executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecute() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsync(ct) |> Async.AwaitTask
              }

            member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteWithSyncRead() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
              }

            member _.Execute() =
              executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

            #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

            member _.LazyExecuteAsync(?cancellationToken) =
              executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            #endif

            member _.LazyExecute() =
              executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

            member _.ExecuteSingleAsync(?cancellationToken) =
              executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteSingle() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
              }

            member _.ExecuteSingle() =
              executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


          type ``Out`` private (connStr: string, conn: SqlConnection) =

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val connStr = connStr

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val conn = conn

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val configureConn : SqlConnection -> unit = ignore with get, set

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

            member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
              this.userConfigureCmd <- configureCommand
              this

            static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
              ``Out``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

            static member WithConnection(connection) = ``Out``(null, connection)

            member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
              match configureConnection with
              | None -> ()
              | Some config -> this.configureConn <- config
              this

            member this.WithParameters
              (
                ``param1``: string option
              ) =
              let sqlParams =
                [|
                  SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
                |]
              ``Out_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

            member inline this.WithParameters(dto: ^a) =
              let sqlParams =
                [|
                  SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
                |]
              ``Out_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


          type ``TableOutWithDto`` private (connStr: string, conn: SqlConnection) =

            let configureCmd userConfigureCmd (cmd: SqlCommand) =
              cmd.CommandText <- """
                SELECT * FROM OptionTableWithDto

              """
              userConfigureCmd cmd

            let mutable ``ordinal_Col1`` = 0
            let mutable ``ordinal_Col2`` = 0

            let initOrdinals (reader: SqlDataReader) =
              ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
              ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

            let getItem (reader: SqlDataReader) : TableDtos.dbo.OptionTableWithDto =
              {
                ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then None else reader.GetString ``ordinal_Col1`` |> Some
                ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
              }

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val configureConn : SqlConnection -> unit = ignore with get, set

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

            member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
              this.userConfigureCmd <- configureCommand
              this

            static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
              ``TableOutWithDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

            static member WithConnection(connection) = ``TableOutWithDto``(null, connection)

            member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
              match configureConnection with
              | None -> ()
              | Some config -> this.configureConn <- config
              this

            member this.ExecuteAsync(?cancellationToken) =
              executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecute() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsync(ct) |> Async.AwaitTask
              }

            member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteWithSyncRead() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
              }

            member this.Execute() =
              executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

            #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

            member this.LazyExecuteAsync(?cancellationToken) =
              executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            #endif

            member this.LazyExecute() =
              executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

            member this.ExecuteSingleAsync(?cancellationToken) =
              executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteSingle() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
              }

            member this.ExecuteSingle() =
              executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


          type ``TableOutWithoutDto`` private (connStr: string, conn: SqlConnection) =

            let configureCmd userConfigureCmd (cmd: SqlCommand) =
              cmd.CommandText <- """
                SELECT * FROM OptionTableWithoutDto

              """
              userConfigureCmd cmd

            let mutable ``ordinal_Col1`` = 0
            let mutable ``ordinal_Col2`` = 0

            let initOrdinals (reader: SqlDataReader) =
              ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
              ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

            let getItem (reader: SqlDataReader) =
              {|
                ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then None else reader.GetString ``ordinal_Col1`` |> Some
                ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then None else reader.GetInt32 ``ordinal_Col2`` |> Some
              |}

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val configureConn : SqlConnection -> unit = ignore with get, set

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

            member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
              this.userConfigureCmd <- configureCommand
              this

            static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
              ``TableOutWithoutDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

            static member WithConnection(connection) = ``TableOutWithoutDto``(null, connection)

            member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
              match configureConnection with
              | None -> ()
              | Some config -> this.configureConn <- config
              this

            member this.ExecuteAsync(?cancellationToken) =
              executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecute() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsync(ct) |> Async.AwaitTask
              }

            member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteWithSyncRead() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
              }

            member this.Execute() =
              executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

            #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

            member this.LazyExecuteAsync(?cancellationToken) =
              executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            #endif

            member this.LazyExecute() =
              executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

            member this.ExecuteSingleAsync(?cancellationToken) =
              executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteSingle() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
              }

            member this.ExecuteSingle() =
              executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


          [<EditorBrowsable(EditorBrowsableState.Never)>]
          type ``TvpInOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

            let configureCmd (cmd: SqlCommand) =
              cmd.CommandText <- """
                SELECT * FROM @tvp

              """
              cmd.Parameters.AddRange sqlParams
              userConfigureCmd cmd

            let mutable ``ordinal_Foo`` = 0
            let mutable ``ordinal_Bar`` = 0

            let initOrdinals (reader: SqlDataReader) =
              ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
              ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

            let getItem (reader: SqlDataReader) =
              {|
                ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then None else reader.GetInt32 ``ordinal_Foo`` |> Some
                ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then None else reader.GetString ``ordinal_Bar`` |> Some
              |}

            member _.ExecuteAsync(?cancellationToken) =
              executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecute() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsync(ct) |> Async.AwaitTask
              }

            member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteWithSyncRead() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
              }

            member _.Execute() =
              executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

            #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

            member _.LazyExecuteAsync(?cancellationToken) =
              executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            #endif

            member _.LazyExecute() =
              executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

            member _.ExecuteSingleAsync(?cancellationToken) =
              executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteSingle() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
              }

            member _.ExecuteSingle() =
              executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


          type ``TvpInOut`` private (connStr: string, conn: SqlConnection) =

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val connStr = connStr

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val conn = conn

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val configureConn : SqlConnection -> unit = ignore with get, set

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

            member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
              this.userConfigureCmd <- configureCommand
              this

            static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
              ``TvpInOut``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

            static member WithConnection(connection) = ``TvpInOut``(null, connection)

            member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
              match configureConnection with
              | None -> ()
              | Some config -> this.configureConn <- config
              this

            member this.WithParameters
              (
                ``tvp``: seq<TableTypes.``dbo``.``MultiColNull``>
              ) =
              let sqlParams =
                [|
                  SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = ``tvp``)
                |]
              ``TvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

            member inline this.WithParameters(dto: ^a) =
              let sqlParams =
                [|
                  SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNull", Value = (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNull``>) dto))
                |]
              ``TvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


      module ``SubPath`` =


          type ``SelectAllFromTable`` private (connStr: string, conn: SqlConnection) =

            let configureCmd userConfigureCmd (cmd: SqlCommand) =
              cmd.CommandText <- """
                SELECT * FROM Table1

              """
              userConfigureCmd cmd

            let mutable ``ordinal_TableCol1`` = 0
            let mutable ``ordinal_TableCol2`` = 0

            let initOrdinals (reader: SqlDataReader) =
              ``ordinal_TableCol1`` <- reader.GetOrdinal "TableCol1"
              ``ordinal_TableCol2`` <- reader.GetOrdinal "TableCol2"

            let getItem (reader: SqlDataReader) : TableDtos.dbo.Table1 =
              {
                ``TableCol1`` = reader.GetString ``ordinal_TableCol1``
                ``TableCol2`` = if reader.IsDBNull ``ordinal_TableCol2`` then None else reader.GetInt32 ``ordinal_TableCol2`` |> Some
              }

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val configureConn : SqlConnection -> unit = ignore with get, set

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

            member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
              this.userConfigureCmd <- configureCommand
              this

            static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
              ``SelectAllFromTable``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

            static member WithConnection(connection) = ``SelectAllFromTable``(null, connection)

            member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
              match configureConnection with
              | None -> ()
              | Some config -> this.configureConn <- config
              this

            member this.ExecuteAsync(?cancellationToken) =
              executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecute() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsync(ct) |> Async.AwaitTask
              }

            member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteWithSyncRead() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
              }

            member this.Execute() =
              executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

            #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

            member this.LazyExecuteAsync(?cancellationToken) =
              executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            #endif

            member this.LazyExecute() =
              executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

            member this.ExecuteSingleAsync(?cancellationToken) =
              executeQuerySingleAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteSingle() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
              }

            member this.ExecuteSingle() =
              executeQuerySingle connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


      module ``Voption`` =


          [<EditorBrowsable(EditorBrowsableState.Never)>]
          type ``In_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

            let configureCmd (cmd: SqlCommand) =
              cmd.CommandText <- """
                SELECT @param1

              """
              cmd.Parameters.AddRange sqlParams
              userConfigureCmd cmd

            let initOrdinals = ignore<SqlDataReader>

            let getItem (reader: SqlDataReader) =
              if reader.IsDBNull 0 then None else reader.GetString 0 |> Some

            member _.ExecuteAsync(?cancellationToken) =
              executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecute() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsync(ct) |> Async.AwaitTask
              }

            member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteWithSyncRead() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
              }

            member _.Execute() =
              executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

            #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

            member _.LazyExecuteAsync(?cancellationToken) =
              executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            #endif

            member _.LazyExecute() =
              executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

            member _.ExecuteSingleAsync(?cancellationToken) =
              executeQuerySingleAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteSingle() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
              }

            member _.ExecuteSingle() =
              executeQuerySingle connStr conn configureConn configureCmd initOrdinals getItem


          type ``In`` private (connStr: string, conn: SqlConnection) =

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val connStr = connStr

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val conn = conn

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val configureConn : SqlConnection -> unit = ignore with get, set

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

            member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
              this.userConfigureCmd <- configureCommand
              this

            static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
              ``In``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

            static member WithConnection(connection) = ``In``(null, connection)

            member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
              match configureConnection with
              | None -> ()
              | Some config -> this.configureConn <- config
              this

            member this.WithParameters
              (
                ``param1``: string voption
              ) =
              let sqlParams =
                [|
                  SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = ValueOption.toDbNull ``param1``)
                |]
              ``In_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

            member inline this.WithParameters(dto: ^a) =
              let sqlParams =
                [|
                  SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = ValueOption.toDbNull (^a: (member ``Param1``: string voption) dto))
                |]
              ``In_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


          [<EditorBrowsable(EditorBrowsableState.Never)>]
          type ``Out_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

            let configureCmd (cmd: SqlCommand) =
              cmd.CommandText <- """
                SELECT @param1

              """
              cmd.Parameters.AddRange sqlParams
              userConfigureCmd cmd

            let initOrdinals = ignore<SqlDataReader>

            let getItem (reader: SqlDataReader) =
              if reader.IsDBNull 0 then ValueNone else reader.GetString 0 |> ValueSome

            member _.ExecuteAsync(?cancellationToken) =
              executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecute() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsync(ct) |> Async.AwaitTask
              }

            member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteWithSyncRead() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
              }

            member _.Execute() =
              executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

            #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

            member _.LazyExecuteAsync(?cancellationToken) =
              executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            #endif

            member _.LazyExecute() =
              executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

            member _.ExecuteSingleAsync(?cancellationToken) =
              executeQuerySingleAsyncVoption connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteSingle() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
              }

            member _.ExecuteSingle() =
              executeQuerySingleVoption connStr conn configureConn configureCmd initOrdinals getItem


          type ``Out`` private (connStr: string, conn: SqlConnection) =

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val connStr = connStr

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val conn = conn

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val configureConn : SqlConnection -> unit = ignore with get, set

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

            member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
              this.userConfigureCmd <- configureCommand
              this

            static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
              ``Out``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

            static member WithConnection(connection) = ``Out``(null, connection)

            member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
              match configureConnection with
              | None -> ()
              | Some config -> this.configureConn <- config
              this

            member this.WithParameters
              (
                ``param1``: string option
              ) =
              let sqlParams =
                [|
                  SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull ``param1``)
                |]
              ``Out_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

            member inline this.WithParameters(dto: ^a) =
              let sqlParams =
                [|
                  SqlParameter("@param1", SqlDbType.NVarChar, Size = 50, Value = Option.toDbNull (^a: (member ``Param1``: string option) dto))
                |]
              ``Out_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)


          type ``TableOutWithDto`` private (connStr: string, conn: SqlConnection) =

            let configureCmd userConfigureCmd (cmd: SqlCommand) =
              cmd.CommandText <- """
                SELECT * FROM VoptionTableWithDto

              """
              userConfigureCmd cmd

            let mutable ``ordinal_Col1`` = 0
            let mutable ``ordinal_Col2`` = 0

            let initOrdinals (reader: SqlDataReader) =
              ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
              ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

            let getItem (reader: SqlDataReader) : TableDtos.dbo.VoptionTableWithDto =
              {
                ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then ValueNone else reader.GetString ``ordinal_Col1`` |> ValueSome
                ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then ValueNone else reader.GetInt32 ``ordinal_Col2`` |> ValueSome
              }

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val configureConn : SqlConnection -> unit = ignore with get, set

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

            member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
              this.userConfigureCmd <- configureCommand
              this

            static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
              ``TableOutWithDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

            static member WithConnection(connection) = ``TableOutWithDto``(null, connection)

            member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
              match configureConnection with
              | None -> ()
              | Some config -> this.configureConn <- config
              this

            member this.ExecuteAsync(?cancellationToken) =
              executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecute() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsync(ct) |> Async.AwaitTask
              }

            member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteWithSyncRead() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
              }

            member this.Execute() =
              executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

            #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

            member this.LazyExecuteAsync(?cancellationToken) =
              executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            #endif

            member this.LazyExecute() =
              executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

            member this.ExecuteSingleAsync(?cancellationToken) =
              executeQuerySingleAsyncVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteSingle() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
              }

            member this.ExecuteSingle() =
              executeQuerySingleVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


          type ``TableOutWithoutDto`` private (connStr: string, conn: SqlConnection) =

            let configureCmd userConfigureCmd (cmd: SqlCommand) =
              cmd.CommandText <- """
                SELECT * FROM VoptionTableWithoutDto

              """
              userConfigureCmd cmd

            let mutable ``ordinal_Col1`` = 0
            let mutable ``ordinal_Col2`` = 0

            let initOrdinals (reader: SqlDataReader) =
              ``ordinal_Col1`` <- reader.GetOrdinal "Col1"
              ``ordinal_Col2`` <- reader.GetOrdinal "Col2"

            let getItem (reader: SqlDataReader) =
              {|
                ``Col1`` = if reader.IsDBNull ``ordinal_Col1`` then ValueNone else reader.GetString ``ordinal_Col1`` |> ValueSome
                ``Col2`` = if reader.IsDBNull ``ordinal_Col2`` then ValueNone else reader.GetInt32 ``ordinal_Col2`` |> ValueSome
              |}

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val configureConn : SqlConnection -> unit = ignore with get, set

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

            member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
              this.userConfigureCmd <- configureCommand
              this

            static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
              ``TableOutWithoutDto``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

            static member WithConnection(connection) = ``TableOutWithoutDto``(null, connection)

            member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
              match configureConnection with
              | None -> ()
              | Some config -> this.configureConn <- config
              this

            member this.ExecuteAsync(?cancellationToken) =
              executeQueryEagerAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecute() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsync(ct) |> Async.AwaitTask
              }

            member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryEagerAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteWithSyncRead() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
              }

            member this.Execute() =
              executeQueryEager connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

            #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

            member this.LazyExecuteAsync(?cancellationToken) =
              executeQueryLazyAsync connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryLazyAsyncWithSyncRead connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            #endif

            member this.LazyExecute() =
              executeQueryLazy connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem

            member this.ExecuteSingleAsync(?cancellationToken) =
              executeQuerySingleAsyncVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteSingle() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
              }

            member this.ExecuteSingle() =
              executeQuerySingleVoption connStr conn this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem


          [<EditorBrowsable(EditorBrowsableState.Never)>]
          type ``TvpInOut_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, sqlParams: SqlParameter []) =

            let configureCmd (cmd: SqlCommand) =
              cmd.CommandText <- """
                SELECT * FROM @tvp

              """
              cmd.Parameters.AddRange sqlParams
              userConfigureCmd cmd

            let mutable ``ordinal_Foo`` = 0
            let mutable ``ordinal_Bar`` = 0

            let initOrdinals (reader: SqlDataReader) =
              ``ordinal_Foo`` <- reader.GetOrdinal "Foo"
              ``ordinal_Bar`` <- reader.GetOrdinal "Bar"

            let getItem (reader: SqlDataReader) =
              {|
                ``Foo`` = if reader.IsDBNull ``ordinal_Foo`` then ValueNone else reader.GetInt32 ``ordinal_Foo`` |> ValueSome
                ``Bar`` = if reader.IsDBNull ``ordinal_Bar`` then ValueNone else reader.GetString ``ordinal_Bar`` |> ValueSome
              |}

            member _.ExecuteAsync(?cancellationToken) =
              executeQueryEagerAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecute() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsync(ct) |> Async.AwaitTask
              }

            member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryEagerAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteWithSyncRead() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
              }

            member _.Execute() =
              executeQueryEager connStr conn configureConn configureCmd initOrdinals getItem

            #if (!NETFRAMEWORK && !NET461 && !NET462 && !NET47 && !NET471 && !NET472 && !NET48 && !NETSTANDARD2_0 && !NETCOREAPP2_0 && !NETCOREAPP2_1 && !NETCOREAPP2_2)

            member _.LazyExecuteAsync(?cancellationToken) =
              executeQueryLazyAsync connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
              executeQueryLazyAsyncWithSyncRead connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            #endif

            member _.LazyExecute() =
              executeQueryLazy connStr conn configureConn configureCmd initOrdinals getItem

            member _.ExecuteSingleAsync(?cancellationToken) =
              executeQuerySingleAsyncVoption connStr conn configureConn configureCmd initOrdinals getItem (defaultArg cancellationToken CancellationToken.None)

            member this.AsyncExecuteSingle() =
              async {
                let! ct = Async.CancellationToken
                return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
              }

            member _.ExecuteSingle() =
              executeQuerySingleVoption connStr conn configureConn configureCmd initOrdinals getItem


          type ``TvpInOut`` private (connStr: string, conn: SqlConnection) =

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val connStr = connStr

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val conn = conn

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val configureConn : SqlConnection -> unit = ignore with get, set

            [<EditorBrowsable(EditorBrowsableState.Never)>]
            member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

            member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
              this.userConfigureCmd <- configureCommand
              this

            static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
              ``TvpInOut``(connectionString, null).ConfigureConnection(?configureConnection=configureConnection)

            static member WithConnection(connection) = ``TvpInOut``(null, connection)

            member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
              match configureConnection with
              | None -> ()
              | Some config -> this.configureConn <- config
              this

            member this.WithParameters
              (
                ``tvp``: seq<TableTypes.``dbo``.``MultiColNullVoption``>
              ) =
              let sqlParams =
                [|
                  SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNullVoption", Value = ``tvp``)
                |]
              ``TvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)

            member inline this.WithParameters(dto: ^a) =
              let sqlParams =
                [|
                  SqlParameter("@tvp", SqlDbType.Structured, TypeName = "dbo.MultiColNullVoption", Value = (^a: (member ``Tvp``: #seq<TableTypes.``dbo``.``MultiColNullVoption``>) dto))
                |]
              ``TvpInOut_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, sqlParams)
